<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MIDI ArduinoIDE PRO V9.1 (Optimized)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.js"></script>
    <style>
        /* =========================================
           V9.1 Theme: Global Heritage (Dark & Gold)
           ========================================= */
        body { 
            font-family: 'Biz UDPGothic', 'Meiryo', sans-serif; 
            background: #121212; 
            color: #e0e0e0; 
            padding: 20px; 
            line-height: 1.6; 
        }
        .container { 
            max-width: 1000px; 
            margin: 0 auto; 
            background: #1e1e1e; 
            padding: 30px; 
            border-radius: 8px; 
            box-shadow: 0 15px 50px rgba(0,0,0,0.9); 
            border-top: 4px solid #ffd700;
            position: relative;
        }
        
        /* Header & Lang Switch */
        header {
            display: flex; justify-content: space-between; align-items: flex-start;
            border-bottom: 1px solid #444; padding-bottom: 15px; margin-bottom: 25px; 
        }
        h1 { 
            margin: 0; color: #fff; font-size: 22px; letter-spacing: 1px; 
        }
        h1 span { 
            font-size: 0.6em; background: #ffd700; color: #000; 
            font-weight:800; padding: 3px 8px; border-radius: 2px; 
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            margin-left: 10px;
        }
        .header-btns {
            display: flex; gap: 10px; align-items: center;
        }
        .lang-btn {
            background: #333; color: #ccc; border: 1px solid #555;
            padding: 5px 10px; cursor: pointer; font-size: 12px; border-radius: 4px;
        }
        .lang-btn:hover { background: #444; color: #fff; }

        /* --- MODE TABS (NEW) --- */
        .mode-tabs {
            display: flex; background: #333; border-radius: 4px; padding: 2px; margin-right: 10px;
        }
        .tab-btn {
            border: none; background: transparent; color: #aaa;
            padding: 6px 12px; cursor: pointer; font-weight: bold; border-radius: 3px;
            transition: 0.2s; font-size: 12px;
        }
        .tab-btn.active {
            background: #ffd700; color: #000; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .tab-btn:hover:not(.active) { color: #fff; background: #444; }

        /* Quick Start */
        .quick-start {
            background: #252526; border: 1px dashed #555; padding: 15px;
            margin-bottom: 20px; font-size: 0.9em; color: #bbb;
        }
        .quick-start h3 { margin-top: 0; font-size: 1em; color: #ffd700; margin-bottom: 8px; }
        .quick-start ol { margin: 0; padding-left: 20px; }
        .quick-start li { margin-bottom: 4px; }

        /* Controls */
        .controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .controls-row2 { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 20px; }
        
        label { display: block; font-weight: bold; margin-bottom: 8px; color: #aaa; font-size: 0.75em; text-transform: uppercase; letter-spacing: 0.05em; }
        .highlight-label { color: #ffd700; }

        input, select { 
            width: 100%; padding: 10px; box-sizing: border-box;
            background: #2d2d2d; border: 1px solid #444; 
            color: white; border-radius: 4px; font-size: 14px;
        }
        input:focus, select:focus { border-color: #ffd700; outline: none; background: #333; }

        /* --- FIXED STANDARD SLIDER STYLING --- */
        input[type=range] {
            -webkit-appearance: none; width: 100%; height: 6px; 
            background: #444; border-radius: 3px; outline: none; margin: 10px 0; cursor: pointer; border: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; border-radius: 50%; background: #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor: pointer; border: none; margin-top: -1px;
        }
        input[type=range]::-moz-range-thumb {
            width: 16px; height: 16px; border: none; border-radius: 50%;
            background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor: pointer;
        }
        /* Disabled state for sliders */
        input[type=range]:disabled { opacity: 0.3; cursor: not-allowed; }

        /* --- TOGGLE SWITCH (NEW) --- */
        .toggle-switch {
            position: relative; display: inline-block; width: 40px; height: 20px; vertical-align: middle;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider-sw {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444; transition: .4s; border-radius: 20px;
        }
        .slider-sw:before {
            position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider-sw { background-color: #ffd700; }
        input:checked + .slider-sw:before { transform: translateX(20px); }

        /* Mixer Panel */
        .mixer-panel {
            background: #252526; border: 1px solid #333;
            border-radius: 6px; padding: 20px; margin-bottom: 25px;
            display: none; /* Initially hidden */
        }
        .mixer-header {
            font-size: 0.85em; color: #aaa; border-bottom: 1px solid #444; 
            padding-bottom: 8px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;
        }
        .btn-reset {
            background: #444; color: #fff; border: none; padding: 4px 10px;
            font-size: 0.8em; cursor: pointer; border-radius: 3px;
        }
        .btn-reset:hover { background: #666; }

        /* Mixer Channels (Standard) */
        .mixer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;}
        .channel-strip {
            background: #1a1a1a; padding: 15px; border-radius: 4px;
            border-top: 3px solid #555; text-align: center;
        }
        .ch-melody { border-top-color: #ff4081; } 
        .ch-bass   { border-top-color: #00e5ff; } 
        .ch-acc    { border-top-color: #ffd740; } 
        
        .role-tag {
            display: inline-block; font-size: 0.7em; padding: 2px 8px; border-radius: 20px;
            color: #121212; font-weight: 800; margin-bottom: 12px;
        }
        .tag-melody { background: #ff4081; }
        .tag-bass   { background: #00e5ff; }
        .tag-acc    { background: #ffd740; }
        
        .param-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.75em; color: #ccc; margin-bottom: 5px; }
        select.mini-select { padding: 2px 4px; font-size: 11px; width: auto; background: #222; border: 1px solid #555; height: 24px; }

        /* PRO Mode Panel Styles */
        #proPanel {
            display: none; background: #252526; 
            border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #00e5ff;
            padding: 10px;
        }
        .pro-track-row {
            display: grid; 
            grid-template-columns: 30px 2fr 100px 60px 80px 80px; 
            gap: 10px; 
            align-items: center;
            background: #1a1a1a; 
            padding: 8px; 
            border-radius: 4px; 
            border-left: 3px solid #555;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
        .pro-track-row.editing { border-left-color: #ffd700; background: #333; }
        .pro-track-row.muted { opacity: 0.5; }
        
        .prio-select { background:#222; color:#fff; border:1px solid #444; padding:2px; font-size:0.8em; height: 24px;}
        .btn-mini { padding: 4px 8px; font-size: 10px; cursor: pointer; border-radius: 3px; border:none; color:#fff;}
        .btn-edit { background: #444; }
        .btn-edit.active { background: #ffd700; color:#000; font-weight:bold; }

        /* Extended Mixer Controls */
        .mixer-extended {
            display: grid; grid-template-columns: 1fr 2fr; gap: 20px;
            background: #1a1a1a; padding: 15px; border-radius: 4px; border: 1px solid #333;
        }
        
        /* --- TRIMMING UI --- */
        .trim-container {
            position: relative;
            width: 100%; height: 60px;
            background: #000; border: 1px solid #444; border-radius: 4px;
            overflow: hidden; margin-top: 10px; user-select: none;
        }
        canvas#trimCanvas { width: 100%; height: 100%; display: block; }
        /* Edit Mode Cursor */
        canvas#trimCanvas.edit-mode { cursor: crosshair; }

        .trim-handle {
            position: absolute; top: 0; bottom: 0; width: 16px; 
            background: rgba(255, 215, 0, 0.8); cursor: ew-resize; z-index: 10;
            display: flex; align-items: center; justify-content: center;
        }
        .trim-handle::after { content:'||'; color: #000; font-size: 10px; font-weight: bold; }
        .trim-handle-l { left: 0; border-radius: 4px 0 0 4px; border-right: 1px solid #fff; }
        .trim-handle-r { right: 0; border-radius: 0 4px 4px 0; border-left: 1px solid #fff; }
        
        .trim-mask {
            position: absolute; top:0; bottom:0; background: rgba(0,0,0,0.7); z-index: 5;
        }
        .trim-mask-l { left: 0; width: 0; border-right: 1px solid #ffd700; }
        .trim-mask-r { right: 0; width: 0; border-left: 1px solid #ffd700; }

        .time-labels { display: flex; justify-content: space-between; font-size: 0.75em; color: #ffd700; margin-top: 4px; font-family: monospace; }

        /* Transport */
        .transport {
            margin-top: 20px; display: grid; grid-template-columns: 100px 100px 1fr; gap: 15px; align-items: center;
        }
        .btn-sim { 
            padding: 10px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; color: #fff; 
            text-transform: uppercase; font-size: 0.8em; letter-spacing: 0.5px;
        }
        .btn-play { background: #2e7d32; } .btn-play:hover { background: #4caf50; }
        .btn-stop { background: #c62828; } .btn-stop:hover { background: #ef5350; }

        .progress-container { height: 6px; background: #111; border-radius: 3px; overflow: hidden; position: relative; }
        .progress-bar { width: 0%; height: 100%; background: #ffd700; transition: width 0.1s linear; }

        /* Action Buttons */
        .action-area { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px; display:none; }
        .btn-main { 
            background: linear-gradient(135deg, #d32f2f, #b71c1c); color: white; 
            padding: 15px; border: none; border-radius: 4px; 
            width: 100%; font-size: 15px; font-weight: bold; cursor: pointer; 
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .btn-main:hover { background: linear-gradient(135deg, #e53935, #c62828); transform: translateY(-1px); }
        .btn-export { background: linear-gradient(135deg, #1976d2, #0d47a1); }
        .btn-export:hover { background: linear-gradient(135deg, #2196f3, #1565c0); transform: translateY(-1px); }

        /* Report & Code */
        .stats-panel {
            background: #202020; border-left: 5px solid #ffd700;
            padding: 20px; margin-top: 25px; margin-bottom: 25px;
            display: none; border-radius: 0 4px 4px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .report-title { font-weight: bold; font-size: 1.1em; margin-bottom: 12px; color: #e0e0e0; display:flex; align-items:center;}
        .report-title::before { content: '■'; color: #ffd700; margin-right: 8px; font-size: 0.8em; }
        .report-row { margin-bottom: 6px; font-size: 0.95em; color: #ccc; }
        .report-label { color: #aaa; margin-right: 5px; }

        pre { 
            background: #000; color: #00e676; 
            padding: 20px; border-radius: 4px; overflow-x: auto; height: 300px; 
            border: 1px solid #333; font-family: 'Consolas', monospace; font-size: 13px; display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>MIDI ArduinoIDE <span>PRO V9.1</span></h1>
        <div class="header-btns">
            <div class="mode-tabs">
                <button id="tabStd" class="tab-btn active" onclick="setMode('Standard')">STANDARD</button>
                <button id="tabPro" class="tab-btn" onclick="setMode('Pro')">PRO MODE</button>
            </div>
            <button class="lang-btn" onclick="toggleLanguage()" id="btnLang">English</button>
        </div>
    </header>

    <div class="quick-start">
        <h3 id="qsTitle">QUICK START</h3>
        <ol>
            <li id="qs1">Select a MIDI file (or use the loaded sample).</li>
            <li id="qs2">Adjust settings (Volume, Tuning, Trim).</li>
            <li id="qs3">Check with [PLAY] and click [GENERATE SKETCH].</li>
        </ol>
    </div>
    
    <div class="controls">
        <div>
            <label id="lblMidi">1. MIDI File (.mid)</label>
            <input type="file" id="midiInput" accept=".mid,.midi">
        </div>
        <div>
            <label id="lblTarget">2. Target & Engine</label>
            <div style="display:flex; gap:5px;">
                <select id="mcuSelect" onchange="toggleEngineUI(); updateLiveVoices()" style="flex:1;">
                    <option value="R4">Arduino UNO R4</option>
                    <option value="R3">Arduino UNO R3 (12-Voice 1-bit)</option>
                    <option value="ESP32">ESP32 (High Fidelity)</option>
                </select>
                <select id="engineSelect" onchange="toggleEngineUI(); updateLiveVoices()" style="flex:1; display:none;">
                    <option value="PWM">PWM (Poly + Vol)</option>
                    <option value="1BIT">1-bit (Retro/Solid)</option>
                </select>
            </div>
        </div>
        <div>
            <label id="lblVoice">3. Voices (Pins)</label>
            <div style="display:flex; justify-content:space-between; color:#ffd700; font-size:0.8em; margin-bottom:2px;">
                <span id="voiceCountDisp">8</span>
            </div>
            <input type="range" id="voiceCount" min="1" max="12" value="8" step="1" oninput="updateVoiceLimit(); updateSliderFill(this, '#ffd700');">
        </div>
    </div>
    
    <div class="controls-row2">
        <div>
            <label class="highlight-label" id="lblTuning">4. Global Tuning / Scale Mode</label>
            <select id="tuningSelect" onchange="updateLiveVoices()">
                <optgroup label="--- Standard ---">
                    <option value="12TET" selected>12-TET (Standard Average)</option>
                </optgroup>
                <optgroup label="1. Western History & Classical">
                    <option value="Pythagorean">Pythagorean (5ths)</option>
                    <option value="Just">Just Intonation (Pure Major)</option>
                    <option value="Meantone">Meantone (1/4 Comma)</option>
                    <option value="Werckmeister">Werckmeister III (Bach)</option>
                    <option value="Kirnberger">Kirnberger III (Beethoven)</option>
                    <option value="Vallotti">Vallotti (Baroque Standard)</option>
                    <option value="Young">Young (Well Temperament)</option>
                </optgroup>
                <optgroup label="2. Asia & Ethnic">
                    <option value="Miyako">Miyako-Bushi (Japan/Gloomy)</option>
                    <option value="Ryukyu">Ryukyu (Okinawa/Bright)</option>
                    <option value="Minchao">Min-chao (China Pentatonic)</option>
                    <option value="Arabic">Arabic (Maqam Rast / Microtone)</option>
                    <option value="Slendro">Slendro (Gamelan 5)</option>
                    <option value="Pelog">Pelog (Gamelan 7)</option>
                </optgroup>
                <optgroup label="3. Modern & Experimental">
                    <option value="19TET">19-TET (19 Tone/Oct)</option>
                    <option value="31TET">31-TET (31 Tone/Oct)</option>
                    <option value="WholeTone">Whole Tone (Dreamy)</option>
                    <option value="BlueNote">Blue Note (Jazz/Blues)</option>
                    <option value="Detuned">Detuned 8-bit (Retro/Wobbly)</option>
                    <option value="Dorian">Dorian Mode (Medieval/RPG)</option>
                </optgroup>
            </select>
        </div>
        <div>
        </div>
    </div>

    <div id="mixerPanel" class="mixer-panel">
        <div class="mixer-header">
            <span style="font-weight:bold; color:#fff;" id="hdrMixer">REALTIME MIXER & EDITOR</span>
            <div>
                <span id="trackInfoStatus" style="margin-right:15px; font-size:0.9em;"></span>
                <button class="btn-reset" onclick="resetMixerSettings()" id="btnReset">RESET SETTINGS</button>
            </div>
        </div>
        
        <div class="mixer-grid" id="standardMixer">
            <div class="channel-strip ch-melody">
                <span class="role-tag tag-melody">MELODY</span>
                <div class="param-row">
                    <span id="lblVolMelody">Vol: <span id="dispMelody">150%</span></span>
                    <select id="octMelody" class="mini-select" onchange="updateLiveVoices()">
                        <option value="36">+3 Oct</option>
                        <option value="24">+2 Oct</option>
                        <option value="12" selected>+1 Oct</option>
                        <option value="0">±0</option>
                        <option value="-12">-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                    </select>
                </div>
                <div id="wrapVolMelody" style="display:block;">
                    <input type="range" id="volMelody" min="0" max="600" value="150" oninput="updateLiveVoices('Melody'); updateSliderFill(this, '#ff4081');">
                </div>
                <div id="wrapSwMelody" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swMelody" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>
            
            <div class="channel-strip ch-bass">
                <span class="role-tag tag-bass">BASS</span>
                <div class="param-row">
                    <span id="lblVolBass">Vol: <span id="dispBass">100%</span></span>
                    <select id="octBass" class="mini-select" onchange="updateLiveVoices()">
                        <option value="12">+1 Oct</option>
                        <option value="0">±0</option>
                        <option value="-12" selected>-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                        <option value="-36">-3 Oct</option>
                    </select>
                </div>
                <div id="wrapVolBass" style="display:block;">
                    <input type="range" id="volBass" min="0" max="600" value="100" oninput="updateLiveVoices('Bass'); updateSliderFill(this, '#00e5ff');">
                </div>
                <div id="wrapSwBass" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swBass" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>

            <div class="channel-strip ch-acc">
                <span class="role-tag tag-acc">BACKING</span>
                <div class="param-row">
                    <span id="lblVolAcc">Vol: <span id="dispAcc">70%</span></span>
                    <select id="octAcc" class="mini-select" onchange="updateLiveVoices()">
                        <option value="24">+2 Oct</option>
                        <option value="12">+1 Oct</option>
                        <option value="0" selected>±0</option>
                        <option value="-12">-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                    </select>
                </div>
                <div id="wrapVolAcc" style="display:block;">
                    <input type="range" id="volAcc" min="0" max="600" value="70" oninput="updateLiveVoices('Acc'); updateSliderFill(this, '#ffd740');">
                </div>
                <div id="wrapSwAcc" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swAcc" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>
        </div>

        <div id="proPanel">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h3 style="margin:0; color:#00e5ff; font-size:1em;">PRO TRACK MANAGER</h3>
                <label style="color:#e0e0e0; font-size:0.9em; cursor:pointer; display:flex; align-items:center;">
                    <input type="checkbox" id="chkFixedMax" onchange="generateReportAndCode(true)" style="width:auto; margin-right:5px;"> 
                    <span id="lblFixedMax">Fixed Max Vol (Ignore Velocity)</span>
                </label>
            </div>
            <div style="display:grid; grid-template-columns: 30px 2fr 100px 60px 80px 80px; gap:10px; color:#888; font-size:0.7em; margin-bottom:5px; padding:0 10px;">
                <span>#</span><span>Track Name</span><span>Vol</span><span>Oct</span><span>Priority</span><span>Action</span>
            </div>
            <div id="proTrackList" style="max-height:300px; overflow-y:auto;"></div>
        </div>

        <div class="mixer-extended">
            <div style="text-align:center;">
                <label style="color:#fff;" id="lblSpeed">PLAYBACK SPEED</label>
                <div style="color:#ffd700; font-weight:bold; font-size:1.2em; margin:5px 0;" id="speedDisplay">x 1.0</div>
                <input type="range" id="speedRange" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateSpeed(); updateSliderFill(this, '#ffd700');">
            </div>

            <div>
                <label style="color:#fff; display:flex; justify-content:space-between; margin-bottom:10px;">
                    <span id="lblRange">TRIMMING (MIDI TIMELINE)</span>
                    <span id="lblEditHint" style="font-size:0.8em; color:#ffd700; display:none;">* Edit Mode: Click note to Mute/Unmute</span>
                </label>
                
                <div class="trim-container" id="trimContainer">
                    <canvas id="trimCanvas"></canvas>
                    <div class="trim-mask trim-mask-l" id="trimMaskL"></div>
                    <div class="trim-mask trim-mask-r" id="trimMaskR"></div>
                    <div class="trim-handle trim-handle-l" id="trimHandleL"></div>
                    <div class="trim-handle trim-handle-r" id="trimHandleR"></div>
                </div>

                <div class="time-labels">
                    <span id="dispStart">0:00</span>
                    <span id="dispEnd">0:00</span>
                </div>
                <div style="font-size:0.75em; color:#666; margin-top:5px; text-align:right;" id="lblRangeNote">
                    * Output will be shifted to start at 0s.
                </div>
            </div>
        </div>

        <div class="transport">
            <button class="btn-sim btn-play" onclick="startSimulation()" id="btnPlay">PLAY</button>
            <button class="btn-sim btn-stop" onclick="stopSimulation()" id="btnStop">STOP</button>
            <div>
                <div class="progress-container">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <div style="text-align:right; font-size:0.75em; color:#888; margin-top:4px; font-family:monospace;">
                    <span id="timeDisplay">0:00 / 0:00</span>
                </div>
            </div>
        </div>
    </div>

    <div id="actionArea" class="action-area">
        <button class="btn-main" onclick="generateReportAndCode()" id="btnGen">GENERATE SKETCH</button>
        <button class="btn-main btn-export" onclick="exportModifiedMidi()" id="btnExp">EXPORT MIDI (.mid)</button>
    </div>
    
    <div id="statsPanel" class="stats-panel"></div>

    <pre id="codeDisplay"></pre>
</div>

<script>
// ==========================================
// Language Dictionary (JP/EN)
// ==========================================
const LANG = {
    ja: {
        qsTitle: "操作方法",
        qs1: "MIDIファイルを選択（または自動ロードされたサンプルを使用）",
        qs2: "設定を調整 (音量, 音律, トリミング)",
        qs3: "[再生]で確認し、[スケッチ生成]をクリック",
        lblMidi: "1. MIDIファイル (.mid)",
        lblTarget: "2. ターゲット & エンジン",
        lblVoice: "3. パッシブブザー数 (ピン数)",
        lblTuning: "4. 音律 / スケールモード",
        hdrMixer: "リアルタイム・ミキサー (設定 & 調整)",
        btnReset: "設定リセット",
        lblSpeed: "再生速度",
        lblRange: "トリミング (MIDIタイムライン)",
        lblStart: "開始",
        lblEnd: "終了",
        lblRangeNote: "* 出力時、開始位置は0秒に詰められます。",
        btnPlay: "再生 (プレビュー)",
        btnStop: "停止",
        btnGen: "スケッチ生成 (C++)",
        btnExp: "MIDI書き出し (.mid)",
        btnLang: "English",
        trackInfo: "トラック数",
        events: "イベント数",
        reportTitle: "スケッチレポート",
        dropRate: "脱落率",
        pins: "使用ピン",
        target: "ターゲット",
        system: "音律システム"
    },
    en: {
        qsTitle: "How to use",
        qs1: "Select a MIDI file (or use loaded sample)",
        qs2: "Adjust settings (Vol, Tuning, Trim)",
        qs3: "Check with [PLAY] and click [GENERATE SKETCH]",
        lblMidi: "1. MIDI File (.mid)",
        lblTarget: "2. Target & Engine",
        lblVoice: "3. Passive Buzzers (Pins)",
        lblTuning: "4. Global Tuning / Scale Mode",
        hdrMixer: "REALTIME MIXER & EDITOR",
        btnReset: "RESET SETTINGS",
        lblSpeed: "PLAYBACK SPEED",
        lblRange: "TRIMMING (MIDI TIMELINE)",
        lblStart: "START",
        lblEnd: "END",
        lblRangeNote: "* Output starts at 0s (Time Shifted).",
        btnPlay: "PLAY (PREVIEW)",
        btnStop: "STOP",
        btnGen: "GENERATE SKETCH",
        btnExp: "EXPORT MIDI (.mid)",
        btnLang: "日本語",
        trackInfo: "Tracks",
        events: "Events",
        reportTitle: "Generation Report",
        dropRate: "Drop Rate",
        pins: "Pins",
        target: "Target",
        system: "Tuning System"
    }
};
let currentLang = 'ja';

function toggleLanguage() {
    currentLang = (currentLang === 'ja') ? 'en' : 'ja';
    updateLanguageUI();
    if(document.getElementById('statsPanel').style.display === 'block') {
        generateReportAndCode(true); 
    }
}

function updateLanguageUI() {
    const t = LANG[currentLang];
    const setText = (id, txt) => { if(document.getElementById(id)) document.getElementById(id).innerText = txt; };
    
    setText('qsTitle', t.qsTitle);
    setText('qs1', t.qs1);
    setText('qs2', t.qs2);
    setText('qs3', t.qs3);
    setText('lblMidi', t.lblMidi);
    setText('lblTarget', t.lblTarget);
    setText('lblVoice', t.lblVoice);
    setText('lblTuning', t.lblTuning);
    // Dynamic Header
    if(gMode === 'Standard') setText('hdrMixer', t.hdrMixer);
    else if(document.getElementById('hdrMixer')) document.getElementById('hdrMixer').innerText = "PRO MIXER & EDITOR";

    setText('btnReset', t.btnReset);
    setText('lblSpeed', t.lblSpeed);
    setText('lblRange', t.lblRange);
    setText('lblRangeNote', t.lblRangeNote);
    setText('btnPlay', t.btnPlay);
    setText('btnStop', t.btnStop);
    setText('btnGen', t.btnGen);
    setText('btnExp', t.btnExp);
    setText('btnLang', t.btnLang);

    if(gMidi) {
        document.getElementById('trackInfoStatus').innerText = `${t.trackInfo}: ${gMidi.tracks.length} / ${t.events}: ${gRawEvents.length}`;
    }
}

// ==========================================
// V7: グローバル音律データ定義
// ==========================================
const TUNING_DEFS = {
    "12TET":        { type: "offset", val: [0,0,0,0,0,0,0,0,0,0,0,0] },
    "Pythagorean":  { type: "offset", val: [-6, 8, -2, 12, 2, -8, 6, -4, 10, 0, -10, 4] },
    "Just":         { type: "offset", val: [16, -14, 20, 31, 2, 14, -16, 18, 29, 0, 12, 4] },
    "Meantone":     { type: "offset", val: [0, -24, -7, 10, -14, 3, -21, -3, -27, -10, 7, -17] },
    "Werckmeister": { type: "offset", val: [12, 2, 4, 6, 2, 10, 0, 8, 4, 0, 8, 4] },
    "Kirnberger":   { type: "offset", val: [10, 1, 3, 4, -4, 8, -2, 7, 2, 0, 6, -2] },
    "Vallotti":     { type: "offset", val: [6, 0, 2, 4, -2, 8, -2, 4, 2, 0, 6, -4] },
    "Young":        { type: "offset", val: [6, 0, 2, 4, -2, 8, -2, 4, 2, 0, 6, -4] },
    "Arabic":       { type: "offset", val: [0, 0, -50, 0, -50, 0, 0, 0, 0, -50, 0, -50] },

    "Miyako":       { type: "map", val: [0, 1, 1, 1, 5, 5, 5, 7, 8, 8, 8, 0] },
    "Ryukyu":       { type: "map", val: [0, 0, 4, 4, 4, 5, 5, 7, 7, 7, 11, 11] },
    "Minchao":      { type: "map", val: [0, 0, 2, 2, 4, 4, 4, 7, 7, 9, 9, 9] },
    "Slendro":      { type: "map", val: [0, 0, 2, 2, 5, 5, 5, 7, 7, 9, 9, 0] },
    "Pelog":        { type: "map", val: [0, 1, 1, 3, 3, 5, 5, 7, 8, 8, 10, 10] },
    "WholeTone":    { type: "map", val: [0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10] },
    "BlueNote":     { type: "map", val: [0, 0, 0, 3, 3, 5, 6, 7, 7, 7, 10, 10] },
    "Dorian":       { type: "map", val: [0, 0, 2, 3, 3, 5, 5, 7, 7, 9, 10, 10] },

    "19TET":        { type: "math", div: 19 },
    "31TET":        { type: "math", div: 31 },
    "Detuned":      { type: "special", mode: "wobbly" }
};

// ==========================================
// グローバル変数
// ==========================================
let gMidi = null;      
let gTrackRoles = [];
let gRawEvents = []; // {t, type, p, v, dur, role, trackIdx}
let gFilename = "Sample_Morning.mid"; 

let audioCtx = null;
let isPlaying = false;
let scheduleInterval = null;
let uiInterval = null;
let startTime = 0;
let nextNoteIndex = 0;
let totalDuration = 0;
let activeVoices = []; 

// V7.1 State
let gSpeed = 1.0;
let gRangeStart = 0;
let gRangeEnd = 0;

// V8.0 PRO Mode State
let gMode = 'Standard'; // 'Standard' or 'Pro'
let gProSettings = [];  // Array of {vol, oct, prio, mute, name}
let gEditingTrack = -1; // -1:None, >=0: TrackIdx

const PIN_MAP = {
    ESP32: [32, 33, 27, 4, 5, 18, 19, 21, 22, 23, 13, 12], 
    R4:    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    R3:    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14] // 14=A0
};

// ==========================================
// UI Utils & Mode Switching
// ==========================================
function updateSliderFill(el, color) {
    const min = el.min ? parseFloat(el.min) : 0;
    const max = el.max ? parseFloat(el.max) : 100;
    const val = parseFloat(el.value);
    const ratio = (val - min) / (max - min);
    const stopPosition = `calc(${ratio * 100}% + (${8 - ratio * 16}px))`;
    el.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${stopPosition}, #444 ${stopPosition}, #444 100%)`;
}

// 修正: 1bitモード判定とUI切替
function toggleEngineUI() {
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect');
    
    // R4のときだけエンジン選択を表示
    eng.style.display = (mcu === 'R4') ? 'block' : 'none';
    
    // 1-bitモード判定 (R3 または R4かつ1BIT)
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && eng.value === '1BIT');

    // --- Standard Mode UI制御 ---
    ['Melody', 'Bass', 'Acc'].forEach(role => {
        const wrapVol = document.getElementById('wrapVol' + role);
        const wrapSw = document.getElementById('wrapSw' + role);
        const lbl = document.getElementById('lblVol' + role);
        const disp = document.getElementById('disp' + role);
        const slider = document.getElementById('vol' + role);

        if(is1Bit) {
            // 1-bit: スライダー隠す、スイッチ出す
            if(wrapVol) wrapVol.style.display = 'none';
            if(wrapSw) wrapSw.style.display = 'block';
            if(lbl) lbl.innerHTML = "STATUS: "; // ラベル変更
        } else {
            // PWM: スライダー出す、スイッチ隠す
            if(wrapVol) wrapVol.style.display = 'block';
            if(wrapSw) wrapSw.style.display = 'none';
            if(lbl) lbl.innerHTML = "Vol: <span id='disp"+role+"'>"+slider.value+"%</span>";
        }
    });

    // --- Pro Mode UI制御 ---
    // Proリストが生成済みなら再描画して反映
    if(gMode === 'Pro') {
        initProTrackList();
    }
}

// 修正: 新しいモード切替
function setMode(mode) {
    gMode = mode;
    
    // タブの見た目更新
    document.getElementById('tabStd').className = (mode === 'Standard') ? 'tab-btn active' : 'tab-btn';
    document.getElementById('tabPro').className = (mode === 'Pro') ? 'tab-btn active' : 'tab-btn';

    // パネル表示切替
    const mixerStd = document.getElementById('standardMixer');
    const proPanel = document.getElementById('proPanel');
    const mixerHdr = document.getElementById('hdrMixer');

    if(gMode === 'Pro') {
        proPanel.style.display = 'block';
        mixerStd.style.display = 'none';
        if(mixerHdr) mixerHdr.innerText = "PRO MIXER & EDITOR";
        initProTrackList();
    } else {
        proPanel.style.display = 'none';
        mixerStd.style.display = 'grid';
        if(mixerHdr) mixerHdr.innerText = "REALTIME MIXER & EDITOR";
        gEditingTrack = -1;
        initTrimmer(); 
    }
    
    // UI状態（1bitかPWMか）を再評価して表示を更新
    toggleEngineUI();
}

// ==========================================
// 1. SAMPLE MIDI GENERATOR
// ==========================================
function createSampleMidi() {
    // Helper to write variable length quantity
    const vlq = (v) => {
        let b=[]; let x=v;
        do { b.unshift(x&0x7f); x>>=7; } while(x>0);
        for(let i=0; i<b.length-1; i++) b[i]|=0x80;
        return b;
    };
    
    // Minimal Track Writer
    const createTrack = (notes, ch) => {
        let data = [];
        let lastT = 0;
        notes.forEach(n => {
            let dt = n.t - lastT;
            data.push(...vlq(dt));
            data.push(0x90|ch, n.p, 100); // Note On
            lastT = n.t;
            
            dt = n.d;
            data.push(...vlq(dt));
            data.push(0x80|ch, n.p, 0); // Note Off
            lastT += dt;
        });
        data.push(0x00, 0xFF, 0x2F, 0x00);
        const len = data.length;
        return [0x4D, 0x54, 0x72, 0x6B, (len>>24)&0xFF, (len>>16)&0xFF, (len>>8)&0xFF, len&0xFF, ...data];
    };

    // Composition: "Morning Glory"
    let trMelody = [];
    let trBass = [];
    let trAcc = [];
    
    [0, 480*4].forEach(offset => {
        [60, 64, 67, 72, 67, 64].forEach((p, i) => {
            trMelody.push({t: offset + i*480, d: 400, p: p});
        });
        trMelody.push({t: offset + 6*480, d: 800, p: 76}); 
        
        trBass.push({t: offset, d: 480*2, p: 36}); 
        trBass.push({t: offset + 480*2, d: 480*2, p: 43}); 
        trBass.push({t: offset + 480*4, d: 480*2, p: 41}); 
        trBass.push({t: offset + 480*6, d: 480*2, p: 43}); 

        for(let k=0; k<8; k++){
            trAcc.push({t: offset + k*480, d: 100, p: 60}); 
            trAcc.push({t: offset + k*480 + 240, d: 100, p: 64}); 
        }
    });

    const header = [0x4D, 0x54, 0x68, 0x64, 0,0,0,6, 0,1, 0,3, 0x01, 0xE0]; 
    const t1 = createTrack(trMelody, 0);
    const t2 = createTrack(trBass, 1);
    const t3 = createTrack(trAcc, 2);
    
    return new Uint8Array([...header, ...t1, ...t2, ...t3]);
}

// ==========================================
// 2. MIDI Loading & Parsing 
// ==========================================
async function loadMidiData(arrayBuffer, name) {
    try {
        gFilename = name;
        gMidi = new Midi(arrayBuffer);
        const stats = analyzeTracks(gMidi);
        gTrackRoles = classifyTracks(stats);
        gRawEvents = extractRawEvents(gMidi, gTrackRoles);
        
        // 曲の全長を更新
        totalDuration = gMidi.duration;
        
        
        gRangeStart = 0;
        gRangeEnd = totalDuration;
        
        // Reset Pro Settings
        gProSettings = [];
        gEditingTrack = -1;

        initTrimmer(); 
        
        stopSimulation();
        document.getElementById('mixerPanel').style.display = 'block';
        document.getElementById('actionArea').style.display = 'grid';
        updateLanguageUI();
        
        if(gMode === 'Pro') initProTrackList();
        updateLiveVoices();

    } catch(err) {
        alert("Error: " + err);
        console.error(err);
    }
}

// Initial Load
window.onload = () => {
    const sampleBytes = createSampleMidi();
    loadMidiData(sampleBytes.buffer, "Sample_Morning.mid");
    
    updateSliderFill(document.getElementById('voiceCount'), '#ffd700');
    updateSliderFill(document.getElementById('volMelody'), '#ff4081');
    updateSliderFill(document.getElementById('volBass'), '#00e5ff');
    updateSliderFill(document.getElementById('volAcc'), '#ffd740');
    updateSliderFill(document.getElementById('speedRange'), '#ffd700');
    
    toggleEngineUI(); // Init State
};

document.getElementById('midiInput').addEventListener('change', async (e) => {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = async (ev) => loadMidiData(ev.target.result, e.target.files[0].name);
    reader.readAsArrayBuffer(e.target.files[0]);
});

function updateLiveVoices(triggerRole) {
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && engine === '1BIT');

    if(triggerRole && triggerRole !== 'Limit' && gMode==='Standard' && !is1Bit) {
        const val = document.getElementById('vol' + triggerRole).value;
        document.getElementById('disp' + triggerRole).innerText = val + "%";
    }
    if(isPlaying && activeVoices.length > 0) {
        applyLiveParams();
    }
}

function updateVoiceLimit() {
    const val = document.getElementById('voiceCount').value;
    document.getElementById('voiceCountDisp').innerText = val;
    // Remove excess voices
    while(activeVoices.length > val) {
        // Simple removal (PRO logic will handle better stealing later)
        const victim = activeVoices.shift();
        if(victim) try { victim.osc.stop(audioCtx.currentTime); } catch(e){}
    }
}

function updateSpeed() {
    const newSpeed = parseFloat(document.getElementById('speedRange').value);
    document.getElementById('speedDisplay').innerText = "x " + newSpeed.toFixed(1);
    
    if(isPlaying && audioCtx) {
        const now = audioCtx.currentTime;
        const elapsed = now - startTime;
        const currentSongPos = elapsed * gSpeed;
        gSpeed = newSpeed;
        startTime = now - (currentSongPos / gSpeed);
    } else {
        gSpeed = newSpeed;
    }
}

// ==========================================
// 3. PRO Mode UI Functions
// ==========================================
function initProTrackList() {
    const container = document.getElementById('proTrackList');
    container.innerHTML = "";
    
    // 1-bit判定
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && eng.value === '1BIT');
    
    // Initialize if empty
    if(gProSettings.length !== gMidi.tracks.length) {
        gProSettings = gMidi.tracks.map((t, i) => {
            // Auto Priority based on Role
            let prio = 'Mid';
            if(gTrackRoles[i] === 'melody') prio = 'High';
            if(gTrackRoles[i] === 'acc') prio = 'Low';
            
            return {
                vol: 100,
                oct: 0,
                prio: prio,
                mute: false,
                name: t.name || `Track ${i+1}`
            };
        });
    }

    gProSettings.forEach((s, i) => {
        const div = document.createElement('div');
        div.className = `pro-track-row ${s.mute ? 'muted' : ''}`;
        if(gEditingTrack === i) div.classList.add('editing');
        
        // 1-bit時はボリュームスライダーを表示しない
        const volDisplay = is1Bit ? 'visibility:hidden;' : '';

        div.innerHTML = `
            <span style="color:#aaa;">#${i+1}</span>
            <div style="overflow:hidden; white-space:nowrap; text-overflow:ellipsis;" title="${s.name}">${s.name}</div>
            
            <input type="range" min="0" max="200" value="${s.vol}" style="height:4px; ${volDisplay}" 
                oninput="gProSettings[${i}].vol=this.value; updateLiveVoices();">
            
            <select class="prio-select" onchange="gProSettings[${i}].oct=parseInt(this.value); updateLiveVoices();">
                <option value="12" ${s.oct===12?'selected':''}>+1</option>
                <option value="0" ${s.oct===0?'selected':''}>0</option>
                <option value="-12" ${s.oct===-12?'selected':''}>-1</option>
                <option value="-24" ${s.oct===-24?'selected':''}>-2</option>
            </select>

            <select class="prio-select" onchange="gProSettings[${i}].prio=this.value;">
                <option value="High" ${s.prio==='High'?'selected':''}>Hi</option>
                <option value="Mid" ${s.prio==='Mid'?'selected':''}>Mid</option>
                <option value="Low" ${s.prio==='Low'?'selected':''}>Lo</option>
            </select>

            <div style="display:flex; gap:2px;">
                <button class="btn-mini btn-edit ${gEditingTrack===i?'active':''}" onclick="setEditTrack(${i})">EDIT</button>
                <button class="btn-mini" style="background:${s.mute?'#d32f2f':'#444'}" onclick="toggleMute(${i})">${s.mute?'OFF':'ON'}</button>
            </div>
        `;
        container.appendChild(div);
    });
}

function toggleMute(idx) {
    gProSettings[idx].mute = !gProSettings[idx].mute;
    initProTrackList();
    updateLiveVoices(); // Stops muted voices
}

function setEditTrack(idx) {
    if(gEditingTrack === idx) gEditingTrack = -1; 
    else gEditingTrack = idx;
    initProTrackList();
    initTrimmer(); // Redraw canvas with ghosting
}

// ==========================================
// 4. Visual Trimmer & Editor Implementation
// ==========================================
function initTrimmer() {
    gRangeStart = Math.max(0, gRangeStart);
    gRangeEnd = Math.min(totalDuration, gRangeEnd);
    if(gRangeEnd <= gRangeStart) gRangeEnd = totalDuration;

    const container = document.getElementById('trimContainer');
    const canvas = document.getElementById('trimCanvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    // Draw Background
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Edit Mode Hint
    const hint = document.getElementById('lblEditHint');
    hint.style.display = (gMode === 'Pro' && gEditingTrack !== -1) ? 'inline' : 'none';
    if(gMode === 'Pro' && gEditingTrack !== -1) canvas.classList.add('edit-mode');
    else canvas.classList.remove('edit-mode');

    // Draw MIDI Notes
    gRawEvents.forEach(e => {
        if(e.type !== 1) return;
        
        let alpha = 1.0;
        let color = '#fff';
        
        if(gMode === 'Pro' && gEditingTrack !== -1) {
            // Edit Mode: Ghost others
            if(e.trackIdx !== gEditingTrack) {
                alpha = 0.2;
                color = '#888';
            } else {
                // Active Track
                color = (e.v === 0) ? '#444' : '#ffd700'; // Muted (deleted) notes are dark
            }
        } else {
            // Standard/Overview Mode
            color = e.role === 'melody' ? '#ff4081' : (e.role === 'bass' ? '#00e5ff' : '#ffd740');
        }

        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        
        const x = (e.t / totalDuration) * canvas.width;
        const w = Math.max(2, (e.dur / totalDuration) * canvas.width);
        const y = canvas.height - ((e.p / 128) * canvas.height);
        
        ctx.fillRect(x, y - 2, w, 4);
    });
    ctx.globalAlpha = 1.0;

    updateTrimUI();
    setupTrimInteractions();
}

function updateTrimUI() {
    const L = document.getElementById('trimHandleL');
    const R = document.getElementById('trimHandleR');
    const ML = document.getElementById('trimMaskL');
    const MR = document.getElementById('trimMaskR');
    
    const pctL = (gRangeStart / totalDuration) * 100;
    const pctR = (gRangeEnd / totalDuration) * 100;

    L.style.left = pctL + "%";
    R.style.left = pctR + "%";
    ML.style.width = pctL + "%";
    MR.style.width = (100 - pctR) + "%";
    
    document.getElementById('dispStart').innerText = formatTime(gRangeStart);
    document.getElementById('dispEnd').innerText = formatTime(gRangeEnd);
}

function setupTrimInteractions() {
    const con = document.getElementById('trimContainer');
    const L = document.getElementById('trimHandleL');
    const R = document.getElementById('trimHandleR');
    const canvas = document.getElementById('trimCanvas');
    let dragging = null;

    // Canvas Click (Edit Mode)
    canvas.onclick = (e) => {
        if(gMode === 'Pro' && gEditingTrack !== -1) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const t = (x / rect.width) * totalDuration;
            const p = 128 - (y / rect.height) * 128;
            
            // Find note
            const marginT = totalDuration * 0.01; 
            const found = gRawEvents.find(ev => 
                ev.trackIdx === gEditingTrack && ev.type === 1 &&
                t >= ev.t - marginT && t <= ev.t + ev.dur + marginT &&
                Math.abs(ev.p - p) < 5
            );
            
            if(found) {
                // Toggle Mute (Set Velocity to 0 or Restore)
                if(found.v === 0) found.v = found.originalV || 100;
                else { found.originalV = found.v; found.v = 0; }
                initTrimmer(); // Redraw
            }
        }
    };

    // Trim Handles
    const onMove = (e) => {
        if(!dragging) return;
        const rect = con.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let x = clientX - rect.left;
        let pct = Math.max(0, Math.min(1, x / rect.width));
        let t = pct * totalDuration;

        if(dragging === 'L') {
            if(t < gRangeEnd - 0.5) gRangeStart = t;
        } else {
            if(t > gRangeStart + 0.5) gRangeEnd = t;
        }
        updateTrimUI();
        if(isPlaying) stopSimulation();
    };

    const onEnd = () => { dragging = null; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd); };

    L.addEventListener('mousedown', (e) => { e.stopPropagation(); dragging = 'L'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd); });
    R.addEventListener('mousedown', (e) => { e.stopPropagation(); dragging = 'R'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd); });
    
    L.addEventListener('touchstart', (e) => { e.stopPropagation(); dragging = 'L'; });
    R.addEventListener('touchstart', (e) => { e.stopPropagation(); dragging = 'R'; });
    con.addEventListener('touchmove', onMove);
    con.addEventListener('touchend', () => dragging = null);
}

function resetMixerSettings() {
    if(!confirm("Reset all settings?")) return;
    
    // Reset Standard
    ['Melody','Bass','Acc'].forEach(role => {
        const defV = (role==='Melody')?150:(role==='Bass'?100:70);
        const color = (role==='Melody')?'#ff4081':(role==='Bass'?'#00e5ff':'#ffd740');
        const el = document.getElementById('vol'+role);
        el.value = defV;
        updateSliderFill(el, color);
        document.getElementById('disp'+role).innerText = defV + "%";
        // Reset Switch
        const sw = document.getElementById('sw'+role);
        if(sw) sw.checked = true;
    });
    document.getElementById('octMelody').value = "12";
    document.getElementById('octBass').value = "-12";
    document.getElementById('octAcc').value = "0";
    
    // Reset Common
    document.getElementById('tuningSelect').value = "12TET";
    const spd = document.getElementById('speedRange');
    spd.value = "1.0";
    updateSliderFill(spd, '#ffd700');
    gSpeed = 1.0;
    document.getElementById('speedDisplay').innerText = "x 1.0";

    gRangeStart = 0; gRangeEnd = totalDuration;
    
    // Reset Pro
    gProSettings = []; // Will regenerate on next open
    if(gMode === 'Pro') initProTrackList();

    updateTrimUI();
    const vc = document.getElementById('voiceCount');
    vc.value = 8;
    updateSliderFill(vc, '#ffd700');
    updateVoiceLimit();
    toggleEngineUI();
}


// ==========================================
// 5. Sound Engine (Priority & Resource Optimization)
// ==========================================
function getFrequency(midiNote, modeName) {
    if (midiNote < 0) midiNote = 0; if (midiNote > 127) midiNote = 127;
    const baseFreq = 440;
    const def = TUNING_DEFS[modeName] || TUNING_DEFS["12TET"];
    
    if (def.type === "map") {
        const octave = Math.floor(midiNote / 12);
        const noteIdx = midiNote % 12;
        const mappedIdx = def.val[noteIdx];
        midiNote = (octave * 12) + mappedIdx;
        return baseFreq * Math.pow(2, (midiNote - 69) / 12);
    }
    if (def.type === "offset") {
        const noteIdx = midiNote % 12;
        const semitoneOffset = def.val[noteIdx] / 100.0;
        return baseFreq * Math.pow(2, (midiNote - 69 + semitoneOffset) / 12);
    }
    if (def.type === "math") {
        return baseFreq * Math.pow(2, ((midiNote - 69) * (def.div / 12.0)) / def.div);
    }
    if (def.type === "special") {
        const standard = baseFreq * Math.pow(2, (midiNote - 69) / 12);
        return standard * (1.0 + (Math.random() * 0.02 - 0.01));
    }
    return baseFreq * Math.pow(2, (midiNote - 69) / 12);
}

function applyLiveParams() {
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const tuningMode = document.getElementById('tuningSelect').value;
    const ctxTime = audioCtx.currentTime;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && engine === '1BIT');

    activeVoices.forEach(voice => {
        let vol = 1.0;
        let pOffset = 0;
        let isMuted = false;

        if(gMode === 'Standard') {
            const mix = {
                melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
                bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
                acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
            };
            const s = mix[voice.role];
            
            if (is1Bit) {
                // スイッチ状態を確認
                const sw = document.getElementById('sw' + voice.role.charAt(0).toUpperCase() + voice.role.slice(1));
                if (sw && !sw.checked) isMuted = true;
                vol = 1.0;
            } else {
                vol = s.v;
            }
            pOffset = s.p;
        } else {
            const s = gProSettings[voice.trackIdx];
            if(s.mute) isMuted = true;
            else vol = is1Bit ? 1.0 : s.vol / 100;
            pOffset = s.oct;
        }

        if(isMuted || vol <= 0) {
            voice.gain.gain.setTargetAtTime(0, ctxTime, 0.05);
            return;
        }

        const targetPitch = voice.baseMidi + pOffset;
        let freq = getFrequency(targetPitch, tuningMode);
        
        // Auto Target Logic
        if(!is1Bit && mcu === 'R4' && voice.role === 'bass') {
            voice.osc.type = 'sawtooth';
        } else {
            voice.osc.type = 'square';
        }
        
        voice.osc.frequency.setTargetAtTime(freq, ctxTime, 0.05);

        // Preview Volume
        let targetVol = voice.baseVel * vol * 0.05; 
        if(voice.role === 'acc') targetVol *= 0.6;
        if(is1Bit) targetVol = 0.1; // Fixed low volume for previewing 1-bit
        targetVol = Math.min(0.26, targetVol); 
        voice.gain.gain.setTargetAtTime(targetVol, ctxTime, 0.05);
    });
}

function stopSimulation() {
    isPlaying = false;
    if(scheduleInterval) clearInterval(scheduleInterval);
    if(uiInterval) clearInterval(uiInterval);
    if(audioCtx) try { audioCtx.close(); } catch(e){}
    audioCtx = null;
    activeVoices = [];
    document.getElementById('progressBar').style.width = "0%";
}

function startSimulation() {
    stopSimulation();
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();

    isPlaying = true;
    startTime = audioCtx.currentTime + 0.1;
    
    nextNoteIndex = 0;
    while(nextNoteIndex < gRawEvents.length && gRawEvents[nextNoteIndex].t < gRangeStart) {
        nextNoteIndex++;
    }

    scheduleInterval = setInterval(() => {
        if(!isPlaying) return;
        const now = audioCtx.currentTime;
        const elapsed = now - startTime;
        const currentSongTime = (elapsed * gSpeed) + gRangeStart; 
        const lookAhead = 0.1 * gSpeed;

        while(nextNoteIndex < gRawEvents.length) {
            const ev = gRawEvents[nextNoteIndex];
            if(ev.t > currentSongTime + lookAhead) break;
            if(ev.t > gRangeEnd) {
                nextNoteIndex = gRawEvents.length; 
                break;
            }

            const timeUntilEvent = (ev.t - currentSongTime) / gSpeed;
            const playTime = now + timeUntilEvent;
            
            if(playTime >= now) {
                playNote(ev, playTime);
            }
            nextNoteIndex++;
        }
        
        const durationPlayed = (gRangeEnd - gRangeStart) / gSpeed;
        if(elapsed > durationPlayed + 0.5) {
            stopSimulation();
        }
    }, 25);

    uiInterval = setInterval(() => {
        if(!isPlaying) return;
        const elapsed = audioCtx.currentTime - startTime;
        const totalPlayable = (gRangeEnd - gRangeStart) / gSpeed;
        
        const pct = Math.min(100, (elapsed / totalPlayable) * 100);
        document.getElementById('progressBar').style.width = pct + "%";
        
        const currentSongT = Math.min(gRangeEnd, gRangeStart + (elapsed * gSpeed));
        document.getElementById('timeDisplay').innerText = 
            formatTime(currentSongT) + " / " + formatTime(totalDuration) + " (x" + gSpeed.toFixed(1) + ")";

        activeVoices = activeVoices.filter(v => v.endTime > audioCtx.currentTime);
    }, 100);
}

function playNote(ev, time) {
    if(ev.type !== 1) return;
    if(ev.v === 0) return; // Mute/Deleted notes skip

    // 1. 設定値の取得 (Standard/PRO共通)
    let vol = 1.0;
    let pOffset = 0;
    let priority = 1; // 0:Low, 1:Mid, 2:High
    let isMuted = false;
    
    // Check Engine Mode
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && engine === '1BIT');

    if(gMode === 'Standard') {
        const mix = {
            melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
            bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
            acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
        };
        const s = mix[ev.role];
        
        if (is1Bit) {
            // スイッチ状態を確認
            const sw = document.getElementById('sw' + ev.role.charAt(0).toUpperCase() + ev.role.slice(1));
            if (sw && !sw.checked) isMuted = true;
            vol = 1.0;
        } else {
            vol = s.v;
        }
        pOffset = s.p;
        // Standardの優先度: Melody > Bass > Acc
        if(ev.role === 'melody') priority = 2;
        else if(ev.role === 'bass') priority = 1;
        else priority = 0;
    } else {
        // PRO Mode
        const s = gProSettings[ev.trackIdx];
        if(s.mute) isMuted = true;
        vol = is1Bit ? 1.0 : s.vol / 100;
        pOffset = s.oct;
        
        if(s.prio === 'High') priority = 2;
        else if(s.prio === 'Low') priority = 0;
        else priority = 1; // Mid
    }

    if(isMuted) return; // ミュート時は発音しない
    if(!is1Bit && vol <= 0) return; 

    // 2. ボイス割り当て (階層型スチールロジック)
    const maxVoices = parseInt(document.getElementById('voiceCount').value);
    
    if (activeVoices.length >= maxVoices) {
        // 犠牲者を探すソート
        // 第1キー: 優先度 (低い順 0 -> 2)
        // 第2キー: 開始時間 (古い順 = 小さい順)
        activeVoices.sort((a, b) => {
            if(a.priority !== b.priority) return a.priority - b.priority;
            return a.startTime - b.startTime;
        });

        const victim = activeVoices[0]; // 「最も優先度が低く」かつ「最も古い」音

        // 新しい音の優先度が、犠牲者候補「以上」であれば奪い取る
        // (同じ優先度なら、古い音を消して新しい自分が鳴る = New Note Priority)
        if(priority >= victim.priority) {
            try { victim.osc.stop(time); } catch(e){}
            activeVoices.shift(); // 配列から削除
        } else {
            // 自分の優先度が相手より低い (例: 自分がLowで、相手が全員High) 場合のみ
            // 新しい音でも諦める (重要度保護のため)
            return; 
        }
    }

    // 3. 発音処理
    const tuningMode = document.getElementById('tuningSelect').value;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    const pitch = ev.p + pOffset;
    osc.frequency.value = getFrequency(pitch, tuningMode);
    
    osc.type = (!is1Bit && mcu === 'R4' && ev.role === 'bass') ? 'sawtooth' : 'square';
    
    let finalVol = ev.v * vol * 0.05; 
    if(ev.role === 'acc') finalVol *= 0.6;
    if(is1Bit) finalVol = 0.1; // Fixed preview vol for 1-bit

    gain.gain.value = Math.min(0.26, finalVol);

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.start(time);
    const noteDur = ev.dur / gSpeed;
    const endTime = time + noteDur;
    osc.stop(endTime);

    activeVoices.push({
        osc: osc, gain: gain, role: ev.role, trackIdx: ev.trackIdx,
        baseMidi: ev.p, baseVel: ev.v, endTime: endTime,
        priority: priority, startTime: time
    });
}

// ==========================================
// 6. Code Generation & Export (Optimized)
// ==========================================
function getCookedEvents() {
    const tuningMode = document.getElementById('tuningSelect').value;
    const def = TUNING_DEFS[tuningMode] || TUNING_DEFS["12TET"];
    
    // Check global fixed max
    const fixedMax = (gMode === 'Pro' && document.getElementById('chkFixedMax').checked);
    
    // Check Engine Mode for Mute Logic
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && eng.value === '1BIT');

    let cookedEvents = [];
    let idCount = 0;
    
    gMidi.tracks.forEach((t, i) => {
        // Determine Track Settings
        let vol, oct, prio;
        let role = gTrackRoles[i]; 
        let isMuted = false;

        if(gMode === 'Standard') {
            const mix = {
                melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
                bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
                acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
            };
            const s = mix[role];
            
            if (is1Bit) {
                // スイッチ状態を確認 (Standard Mode 1-bit)
                const sw = document.getElementById('sw' + role.charAt(0).toUpperCase() + role.slice(1));
                if (sw && !sw.checked) isMuted = true;
                vol = 1.0;
            } else {
                vol = s.v;
            }
            oct = s.p;
            prio = (role==='melody')?2:(role==='bass'?1:0);
        } else {
            // Pro Mode
            const s = gProSettings[i];
            if(s.mute) isMuted = true;
            vol = s.vol / 100;
            oct = s.oct;
            prio = (s.prio==='High')?2:(s.prio==='Low'?0:1);
        }

        // --- メモリ節約ロジック ---
        // ミュートされている、または(PWMモードで)音量が0以下の場合はデータを生成しない
        if (isMuted || (!is1Bit && vol <= 0)) return;

        t.notes.forEach(n => {
            if(n.time < gRangeStart || n.time > gRangeEnd) return;
            if(n.duration < 0.01) return;
            
            const shiftedStart = (n.time - gRangeStart) / gSpeed;
            const shiftedDur = n.duration / gSpeed;
            
            let p = n.midi + oct;
            if(def.type === "map") {
                const octave = Math.floor(p / 12);
                const noteIdx = p % 12;
                const mappedIdx = def.val[noteIdx];
                p = (octave * 12) + mappedIdx;
            }

            let v = 0;
            if(fixedMax) {
                v = 255; 
            } else {
                let rawV = n.velocity * 127 * vol; 
                v = Math.round(rawV);
                if(v > 250) v = 250; 
            }
            
            p = Math.max(0, Math.min(127, Math.round(p)));
            
            const id = idCount++;
            cookedEvents.push({t: Math.round(shiftedStart*1000), type:1, p:p, v:v, id:id, prio:prio});
            cookedEvents.push({t: Math.round((shiftedStart+shiftedDur)*1000), type:0, p:p, v:0, id:id, prio:prio});
        });
    });
    return cookedEvents.sort((a,b) => (a.t===b.t) ? a.type-b.type : a.t-b.t);
}

function generateReportAndCode(onlyTextUpdate = false) {
    if(!gMidi) return;
    const vCount = parseInt(document.getElementById('voiceCount').value);
    const mcu = document.getElementById('mcuSelect').value;
    const tuningMode = document.getElementById('tuningSelect').value;
    
    const stats = document.getElementById('statsPanel');
    if(onlyTextUpdate && stats.style.display === 'none') return;

    const cookedEvents = getCookedEvents();
    // Simulate with priority logic
    const result = simulateAllocation(cookedEvents, vCount);
    const pins = PIN_MAP[mcu].slice(0, vCount);
    // Correct pin display for R3 A0
    if(mcu === 'R3' && vCount >= 12) pins[11] = "A0";

    const lang = LANG[currentLang];
    
    const dropRate = ((result.dropped / (cookedEvents.length/2)) * 100).toFixed(1);
    
    stats.style.display = 'block';
    stats.innerHTML = `
        <div class="report-title">${lang.reportTitle}</div>
        <div class="report-row"><span class="report-label">${lang.target}:</span> ${mcu} / ${vCount} Voices</div>
        <div class="report-row"><span class="report-label">${lang.system}:</span> <span style="color:#ffd700">${tuningMode}</span></div>
        <div class="report-row"><span class="report-label">Mode:</span> ${gMode}</div>
        <div class="report-row"><span class="report-label">${lang.events}:</span> ${result.events.length}</div>
        <div class="report-row"><span class="report-label">${lang.dropRate}:</span> <span style="color:${parseFloat(dropRate)>5?'#ff5252':'#ffab40'}">${result.dropped} (${dropRate}%)</span></div>
        <div class="report-row" style="font-size:0.8em; margin-top:8px; color:#666;">${lang.pins}: ${pins.join(", ")}</div>
    `;

    if(!onlyTextUpdate) {
        const code = generateSketch(mcu, result.events, vCount, tuningMode);
        const pre = document.getElementById('codeDisplay');
        pre.style.display = 'block';
        pre.textContent = code;
        navigator.clipboard.writeText(code).then(() => alert("Code Copied!"));
    }
}

function exportModifiedMidi() {
    if(!gMidi) return;
    const writeVarLen = (val) => {
        if (val === 0) return [0x00];
        const bytes = [];
        let v = val;
        while (v > 0) {
            bytes.unshift(v & 0x7F);
            v >>= 7;
        }
        for (let i = 0; i < bytes.length - 1; i++) bytes[i] |= 0x80;
        return bytes;
    }

    const events = getCookedEvents();
    let trackData = [];
    let lastT = 0;
    trackData.push(0x00, 0xC0, 80); 

    events.forEach(e => {
        let delta = e.t - lastT;
        if (delta < 0) delta = 0;
        lastT = e.t;
        const dBytes = writeVarLen(delta);
        trackData.push(...dBytes);
        if(e.type === 1) { 
            let v = Math.min(127, e.v);
            trackData.push(0x90, e.p, v);
        } else { 
            trackData.push(0x80, e.p, 0);
        }
    });
    trackData.push(0x00, 0xFF, 0x2F, 0x00);

    const h = [0x4D, 0x54, 0x68, 0x64, 0,0,0,6, 0,0, 0,1, 0x01, 0xF4];
    const trkHead = [0x4D, 0x54, 0x72, 0x6B]; 
    const len = trackData.length;
    const lenBytes = [(len>>24)&0xFF, (len>>16)&0xFF, (len>>8)&0xFF, len&0xFF];

    const finalBytes = new Uint8Array([...h, ...trkHead, ...lenBytes, ...trackData]);
    const blob = new Blob([finalBytes], {type: "audio/midi"});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `V9_Export_${gFilename}.mid`;
    link.click();
}

// ------------------------------------------
// Utils
// ------------------------------------------
function analyzeTracks(midi){
    return midi.tracks.map(t => {
        let sumP=0, sumD=0, cnt=0;
        t.notes.forEach(n=>{sumP+=n.midi; sumD+=n.duration; cnt++});
        return cnt===0 ? {avgP:0, avgD:0} : {avgP:sumP/cnt, avgD:sumD/cnt};
    });
}
function classifyTracks(stats){
    const valid = stats.filter(s=>s.avgP>0);
    const globalP = valid.length ? valid.reduce((s,a)=>s+a.avgP,0)/valid.length : 60;
    return stats.map(s => {
        if(s.avgP===0) return 'acc';
        if(s.avgP < 45) return 'bass';
        if(s.avgP > globalP && s.avgD > 0.25) return 'melody';
        return 'acc';
    });
}
function extractRawEvents(midi, roles) {
    let evs = [];
    midi.tracks.forEach((t, i) => {
        t.notes.forEach(n => {
            if(n.duration >= 0.01) {
                // Add trackIdx and initial status
                evs.push({ t: n.time, type: 1, p: n.midi, v: n.velocity, dur: n.duration, role: roles[i], trackIdx: i });
            }
        });
    });
    return evs.sort((a,b)=>a.t-b.t);
}
function formatTime(s) {
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60);
    return `${m}:${sec.toString().padStart(2,'0')}`;
}

// Updated Allocator with Priority
function simulateAllocation(events, maxV) {
    let voices = Array(maxV).fill(null).map(()=>({act:false, id:-1, t:0, prio:0}));
    let map = new Map();
    let res = [];
    let drop = 0;
    
    for(let e of events) {
        if(e.type===1) {
            // Find empty
            let idx = voices.findIndex(v=>!v.act);
            
            // If full, try steal
            if(idx===-1) {
                // Candidates: lower priority, or same priority but older
                // Sort active voices by Prio (Asc) then Time (Asc = older)
                // We want to find the 'weakest' voice
                let candidates = voices.map((v,i)=>({v,i})).sort((a,b) => {
                    if(a.v.prio !== b.v.prio) return a.v.prio - b.v.prio;
                    return a.v.t - b.v.t; // Older first
                });
                
                let victim = candidates[0];
                
                // If incoming event is Higher or Equal priority, steal
                if(e.prio >= victim.v.prio) {
                    idx = victim.i;
                    if(voices[idx].id!==-1) map.delete(voices[idx].id);
                    drop++; // technically a drop of the old note
                } else {
                    drop++; // Incoming note dropped
                    continue;
                }
            }
            
            voices[idx] = {act:true, id:e.id, t:e.t, prio:e.prio};
            map.set(e.id, idx);
            res.push({t:e.t, type:1, ch:idx, p:e.p, v:e.v});
        } else {
            if(map.has(e.id)) {
                let idx = map.get(e.id);
                if(voices[idx].id===e.id) {
                    voices[idx].act=false;
                    res.push({t:e.t, type:0, ch:idx, p:0, v:0});
                }
                map.delete(e.id);
            }
        }
    }
    return {events:res, dropped:drop};
}

// ==========================================
// 7. Binary Stream Encoder & Code Generator (V9.1)
// ==========================================
function encodeBinaryStream(events) {
    let bytes = [];
    let lastT = 0;

    events.forEach(e => {
        let dt = e.t - lastT;
        lastT = e.t;

        // Delayのエンコード (127msを超える場合は複数回に分ける)
        while(dt > 0) {
            let wait = Math.min(127, dt);
            bytes.push(wait);
            dt -= wait;
        }

        // コマンドのエンコード
        // R3/1-bitはベロシティ無視なので [Cmd+Ch] [Note] の2バイトだけ
        if(e.type === 1) { // Note ON
            bytes.push(0x90 | (e.ch & 0x0F));
            bytes.push(e.p);
        } else { // Note OFF
            bytes.push(0x80 | (e.ch & 0x0F));
            bytes.push(e.p);
        }
    });
    bytes.push(0xF0); // End
    return bytes;
}

function generateSketch(mcu, events, vCount, tuningMode) {
    const d = new Date();
    const dateStr = d.getFullYear() + "-" + (d.getMonth()+1).toString().padStart(2,'0') + "-" + d.getDate().toString().padStart(2,'0');
    const headerInfo = `/* Generated: ${dateStr} | Source: ${gFilename} */`;
    
    // R4のエンジン判定
    const r4Engine = document.getElementById('engineSelect').value;

    // ---------------------------------------------------------
    // R3 (ATmega328P) & R4 1-bit Mode Logic
    // ---------------------------------------------------------
    if (mcu === "R3" || (mcu === "R4" && r4Engine === "1BIT")) {
        const isR3 = (mcu === "R3");
        
        // 周波数テーブル生成 (16bit Step)
        // R3: 15kHz, R4: 24kHz (少し高音質化)
        const SAMPLE_RATE = isR3 ? 15000 : 24000;
        let freqTable = [];
        for(let i=0; i<128; i++){
            const f = getFrequency(i, tuningMode);
            let step = Math.round((f * 65536.0) / SAMPLE_RATE);
            if(step > 65535) step = 65535;
            freqTable.push(step);
        }

        // バイナリストリーム生成
        const binData = encodeBinaryStream(events);
        const hexData = binData.map(b => "0x" + b.toString(16).toUpperCase().padStart(2,'0')).join(",");

        // ピン定義 (R3は A0 を使うように修正)
        let pinDef = "";
        if(isR3) {
            // R3 Pin Mapping logic (Port manipulation requires fixed pins)
            pinDef = "// Pins: 2,3,4,5,6,7,8,9,10,11,12,A0";
        } else {
            const p = PIN_MAP["R4"].slice(0, vCount).join(",");
            pinDef = `const int pins[] = {${p}};`;
        }

        // -----------------------------------------------------
        // R3 Code Template (Memory Optimized)
        // -----------------------------------------------------
        if(isR3) {
            return `${headerInfo}
/* Target: Arduino UNO R3 (ATmega328P)
 * Engine: 12-Voice 1-bit DDS (Memory Optimized Binary Stream)
 * Pins: 2-12, A0 (Total 12)
 */
#include <Arduino.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>

const uint16_t STEPS[] PROGMEM = {${freqTable.join(",")}};
const uint8_t SCORE[] PROGMEM = {${hexData}};

volatile uint16_t acc[12];
volatile uint16_t inc[12];
volatile uint8_t  on[12];

// 15kHz Interrupt
ISR(TIMER1_COMPA_vect) {
  // Voice 0-5 (Port D 2-7)
  acc[0]+=inc[0]; if(on[0]&&(acc[0]<inc[0])) PIND=0x04; // Pin 2
  acc[1]+=inc[1]; if(on[1]&&(acc[1]<inc[1])) PIND=0x08;
  acc[2]+=inc[2]; if(on[2]&&(acc[2]<inc[2])) PIND=0x10;
  acc[3]+=inc[3]; if(on[3]&&(acc[3]<inc[3])) PIND=0x20;
  acc[4]+=inc[4]; if(on[4]&&(acc[4]<inc[4])) PIND=0x40;
  acc[5]+=inc[5]; if(on[5]&&(acc[5]<inc[5])) PIND=0x80; // Pin 7
  
  // Voice 6-10 (Port B 0-4 -> Pins 8-12)
  acc[6]+=inc[6]; if(on[6]&&(acc[6]<inc[6])) PINB=0x01; // Pin 8
  acc[7]+=inc[7]; if(on[7]&&(acc[7]<inc[7])) PINB=0x02;
  acc[8]+=inc[8]; if(on[8]&&(acc[8]<inc[8])) PINB=0x04;
  acc[9]+=inc[9]; if(on[9]&&(acc[9]<inc[9])) PINB=0x08;
  acc[10]+=inc[10]; if(on[10]&&(acc[10]<inc[10])) PINB=0x10; // Pin 12

  // Voice 11 (Port C 0 -> Pin A0)
  acc[11]+=inc[11]; if(on[11]&&(acc[11]<inc[11])) PINC=0x01; // Pin A0 (14)
}

void setup() {
  DDRD |= 0xFC; // 2-7
  DDRB |= 0x1F; // 8-12
  DDRC |= 0x01; // A0
  
  // Timer1 15kHz
  cli();
  TCCR1A = 0; TCCR1B = 0; TCNT1 = 0;
  OCR1A = 1066; // 16MHz/15000
  TCCR1B |= (1 << WGM12) | (1 << CS10);
  TIMSK1 |= (1 << OCIE1A);
  sei();
}

void loop() {
  static uint32_t csr = 0;
  static uint32_t nextT = 0;
  
  if(millis() < nextT) return;

  while(true) {
    uint8_t b = pgm_read_byte(&SCORE[csr++]);
    
    if(b == 0xF0) { // End
       for(int i=0;i<12;i++) on[i]=0; // 全音オフ
       delay(1000);      // 1秒待機
       csr = 0;          // 読み込み位置を最初に戻す
       nextT = millis(); // タイマー基準をリセット
       return;           // loop()の先頭に戻る
    }
    
    if(b < 128) { // Delay
       if(b > 0) {
         nextT = millis() + b;
         return; // Wait until nextT
       }
    } else { // Command
       uint8_t ch = b & 0x0F;
       bool isNoteOn = (b & 0xF0) == 0x90;
       uint8_t note = pgm_read_byte(&SCORE[csr++]);
       
       if(ch < 12) {
         if(isNoteOn) {
           inc[ch] = pgm_read_word(&STEPS[note]);
           on[ch] = 1;
         } else {
           on[ch] = 0;
         }
       }
    }
  }
}`;
        } else {
            // -----------------------------------------------------
            // R4 1-bit Mode Code (High Performance / Register Direct)
            // -----------------------------------------------------
            return `${headerInfo}
/* Target: Arduino UNO R4
 * Engine: ${vCount}-Voice 1-bit DDS (High Performance Register Access)
 */
#include <Arduino.h>
#include "FspTimer.h"

${pinDef}
const uint32_t STEPS[] = {${freqTable.join(",")}};
const uint8_t SCORE[] = {${hexData}};

FspTimer timer;
volatile uint16_t acc[${vCount}];
volatile uint16_t inc[${vCount}];
volatile uint8_t  on[${vCount}];

// 高速化のための構造体
struct PinPtr {
    volatile uint16_t* portReg; // ポート出力レジスタへのポインタ
    uint16_t mask;              // ピンに対応するビットマスク
};
PinPtr pp[${vCount}];

void isr(timer_callback_args_t *args) {
    for(int i=0; i<${vCount}; i++) {
        if(on[i]) {
            acc[i] += inc[i];
            if(acc[i] < inc[i]) {
                // digitalWriteの代わりにレジスタを直接XOR反転（爆速）
                *pp[i].portReg ^= pp[i].mask;
            }
        }
    }
}

void setup() {
    for(int i=0; i<${vCount}; i++) {
        pinMode(pins[i], OUTPUT);
        // R4のレジスタアドレスを計算してキャッシュする
        bsp_io_port_pin_t p = (bsp_io_port_pin_t)g_pin_cfg[pins[i]].pin;
        // PODR (Port Output Data Register) のアドレスを取得
        pp[i].portReg = (volatile uint16_t*)&((R_PORT0_Type*)((uint32_t)R_PORT0 + ((p >> 8) * 0x20)))->PODR;
        pp[i].mask = 1 << (p & 0xFF);
    }
    
    uint8_t type;
    int8_t ch = FspTimer::get_available_timer(type);
    timer.begin(TIMER_MODE_PERIODIC, type, ch, ${SAMPLE_RATE}, 0.0f, isr);
    timer.setup_overflow_irq();
    timer.open();
    timer.start();
}

void loop() {
  static uint32_t csr = 0;
  static uint32_t nextT = 0;
  
  if(millis() < nextT) return;

  while(true) {
    uint8_t b = SCORE[csr++];
    
    if(b == 0xF0) { 
        // 終了時の処理（ループ再生対応済み）
        for(int i=0;i<${vCount};i++) on[i]=0; 
        delay(1000);
        csr = 0;
        nextT = millis();
        return; 
    }
    
    if(b < 128) {
       if(b > 0) { nextT = millis() + b; return; }
    } else {
       uint8_t ch = b & 0x0F;
       bool isNoteOn = (b & 0xF0) == 0x90;
       uint8_t note = SCORE[csr++];
       
       if(ch < ${vCount}) {
         if(isNoteOn) {
           inc[ch] = STEPS[note];
           on[ch] = 1;
         } else {
           on[ch] = 0;
         }
       }
    }
  }
}`;
        }
    }

    // ---------------------------------------------------------
    // R4 (PWM) & ESP32 (Legacy Standard)
    // ---------------------------------------------------------
    const pins = PIN_MAP[mcu] ? PIN_MAP[mcu].slice(0, vCount).join(", ") : "";
    const dataStr = events.map(e => `{${e.t},${e.type},${e.ch},${e.p},${Math.min(255, e.v)}}`).join(",");
    let r4T=[]; let espT=[]; 
    for(let i=0;i<128;i++) {
        const freq = getFrequency(i, tuningMode);
        r4T.push(Math.round(freq * 4294967296.0 / 20000) + "UL");
        espT.push(Math.round(freq));
    }

    if(mcu === "R4") { // R4 PWM Mode
        return `${headerInfo} /* R4 PWM Mode */
#include <Arduino.h>
#include "FspTimer.h"
constexpr uint32_t SR=20000;
constexpr uint8_t NV=${vCount};
const int pins[]={${pins}};
const uint32_t STEP[]={${r4T.join(",")}};
struct E{uint32_t t;uint8_t tp;uint8_t c;uint8_t p;uint8_t v;};
const E sc[]={${dataStr}};
const size_t LEN=${events.length};
FspTimer tm;
struct FP{volatile uint16_t* r;uint16_t m;}; FP fp[NV];
struct V{bool a;uint32_t ph;uint32_t bs;uint32_t cs;int32_t cd;int32_t td;bool b;uint32_t l;};
volatile V v[NV];
void isr(timer_callback_args_t* a){
 static uint32_t tk=0; tk++;
 for(int i=0;i<NV;i++){
  if(v[i].a){
   v[i].l+=(v[i].b)?80:120;
   int32_t dm=0;
   if(v[i].b){int32_t l=(v[i].l>>8)&31;dm=((v[i].l&0x2000)?l:(31-l))*2;}
   else{int32_t m=(v[i].l&0x8000)?250000:-250000;v[i].cs=v[i].bs+m;}
   v[i].ph+=(v[i].b?v[i].bs:v[i].cs);
   if((tk&31)==0){if(v[i].cd>0)v[i].cd--;else{v[i].a=0;*fp[i].r&=~fp[i].m;continue;}}
   if((v[i].ph>>23)<(uint32_t)(v[i].cd+dm<1?1:v[i].cd+dm)) *fp[i].r|=fp[i].m; else *fp[i].r&=~fp[i].m;
  }
 }
}
void setup(){
 for(int i=0;i<NV;i++){
  pinMode(pins[i],OUTPUT);
  bsp_io_port_pin_t p=(bsp_io_port_pin_t)g_pin_cfg[pins[i]].pin;
  fp[i].r=(volatile uint16_t*)&((R_PORT0_Type*)((uint32_t)R_PORT0+((p>>8)*0x20)))->PODR;
  fp[i].m=1<<(p&0xFF);
 }
 uint8_t t;int8_t c=FspTimer::get_available_timer(t);
 tm.begin(TIMER_MODE_PERIODIC,t,c,SR,0.0f,isr);
 tm.setup_overflow_irq();tm.open();tm.start();
}
void loop(){
 static uint32_t st=millis();static size_t i=0;
 if(i>=LEN){delay(1000);for(int j=0;j<NV;j++)v[j].a=0;i=0;st=millis();}
 if(millis()<st)st=millis();
 uint32_t now=millis()-st;
 while(i<LEN){
  if(sc[i].t>now)break;
  if(sc[i].tp==1){
   uint8_t c=sc[i].c;
   if(c<NV){
    v[c].bs=STEP[sc[i].p];v[c].cs=v[c].bs;v[c].l=0;v[c].b=(sc[i].p<55);
    int td=(sc[i].p<55)?120:(sc[i].p>85?40:64);
    int d=map(sc[i].v,0,127,2,td);
    if(sc[i].v > 130) d = td;
    v[c].td=td;v[c].cd=d;v[c].a=1;
   }
  }else{if(sc[i].c<NV)v[sc[i].c].a=0;}
  i++;
 }
}`;
    }

    // ESP32 Code
    return `/* MIDI PRO V9.1 (${tuningMode}) for ESP32 ${headerInfo}
#include <Arduino.h>
constexpr uint8_t NV=${vCount};
const int pins[]={${pins}};
const uint16_t F[]={${espT.join(",")}};
struct E{uint32_t t;uint8_t tp;uint8_t c;uint8_t p;uint8_t v;};
const E sc[]={${dataStr}};
const size_t LEN=${events.length};
#if defined(ESP_ARDUINO_VERSION_MAJOR)&&ESP_ARDUINO_VERSION_MAJOR>=3
#define V3
#else
const int ch[]={0,1,2,3,4,5,6,7,8,9,10,11};
#endif
void setup(){
 for(int i=0;i<NV;i++){
 #ifdef V3
  ledcAttach(pins[i],2000,8);
 #else
  ledcSetup(ch[i],2000,8);ledcAttachPin(pins[i],ch[i]);
 #endif
 }
}
void loop(){
 static uint32_t st=millis();static size_t i=0;
 if(i>=LEN){delay(1000);for(int j=0;j<NV;j++){
  #ifdef V3
  ledcWrite(pins[j],0);
  #else
  ledcWrite(ch[j],0);ledcWriteTone(ch[j],0);
  #endif
 }i=0;st=millis();}
 if(millis()<st)st=millis();
 uint32_t now=millis()-st;
 while(i<LEN){
  if(sc[i].t>now)break;
  if(sc[i].tp==1){
   uint8_t c=sc[i].c; uint8_t p=sc[i].p;
   if(c<NV){
    int maxD = 128; 
    int d = 0;
    if(sc[i].v > 127) {
        d = 128;
    } else {
        int md=(p<55)?128:(p>85?40:64);
        d=map(sc[i].v,1,127,1,md);
    }
    #ifdef V3
    ledcWriteTone(pins[c],F[p]);ledcWrite(pins[c],d);
    #else
    ledcWriteTone(ch[c],F[p]);ledcWrite(ch[c],d);
    #endif
   }
  }else{
   uint8_t c=sc[i].c;
   if(c<NV){
    #ifdef V3
    ledcWrite(pins[c],0);
    #else
    ledcWrite(ch[c],0);ledcWriteTone(ch[c],0);
    #endif
   }
  }
  i++;
 }
}`;
}
updateLanguageUI();
</script>
</body>
</html>

