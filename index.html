<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MIDI ArduinoIDE PRO V9.3 (Optimized)</title>
    <script>
    !function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)("object"==typeof exports?exports:t)[n]=r[n]}}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=5)}([function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(2),i=new WeakMap;e.keySignatureKeys=["Cb","Gb","Db","Ab","Eb","Bb","F","C","G","D","A","E","B","F#","C#"];var a=function(){function t(t){var r=this;this.tempos=[],this.timeSignatures=[],this.keySignatures=[],this.meta=[],this.name="",i.set(this,480),t&&(i.set(this,t.header.ticksPerBeat),t.tracks.forEach((function(t){return t.forEach((function(t){t.meta&&("timeSignature"===t.type?r.timeSignatures.push({ticks:t.absoluteTime,timeSignature:[t.numerator,t.denominator]}):"setTempo"===t.type?r.tempos.push({bpm:6e7/t.microsecondsPerBeat,ticks:t.absoluteTime}):"keySignature"===t.type&&r.keySignatures.push({key:e.keySignatureKeys[t.key+7],scale:0===t.scale?"major":"minor",ticks:t.absoluteTime}))}))})),t.tracks[0].forEach((function(t){t.meta&&("trackName"===t.type?r.name=t.text:"text"!==t.type&&"cuePoint"!==t.type&&"marker"!==t.type&&"lyrics"!==t.type||r.meta.push({text:t.text,ticks:t.absoluteTime,type:t.type}))})),this.update())}return t.prototype.update=function(){var t=this,e=0,r=0;this.tempos.sort((function(t,e){return t.ticks-e.ticks})),this.tempos.forEach((function(n,i){var a=i>0?t.tempos[i-1].bpm:t.tempos[0].bpm,o=n.ticks/t.ppq-r,s=60/a*o;n.time=s+e,e=n.time,r+=o})),this.timeSignatures.sort((function(t,e){return t.ticks-e.ticks})),this.timeSignatures.forEach((function(e,r){var n=r>0?t.timeSignatures[r-1]:t.timeSignatures[0],i=(e.ticks-n.ticks)/t.ppq/n.timeSignature[0]/(n.timeSignature[1]/4);n.measures=n.measures||0,e.measures=i+n.measures}))},t.prototype.ticksToSeconds=function(t){var e=n.search(this.tempos,t);if(-1!==e){var r=this.tempos[e],i=r.time,a=(t-r.ticks)/this.ppq;return i+60/r.bpm*a}return.5*(t/this.ppq)},t.prototype.ticksToMeasures=function(t){var e=n.search(this.timeSignatures,t);if(-1!==e){var r=this.timeSignatures[e],i=(t-r.ticks)/this.ppq;return r.measures+i/(r.timeSignature[0]/r.timeSignature[1])/4}return t/this.ppq/4},Object.defineProperty(t.prototype,"ppq",{get:function(){return i.get(this)},enumerable:!0,configurable:!0}),t.prototype.secondsToTicks=function(t){var e=n.search(this.tempos,t,"time");if(-1!==e){var r=this.tempos[e],i=(t-r.time)/(60/r.bpm);return Math.round(r.ticks+i*this.ppq)}var a=t/.5;return Math.round(a*this.ppq)},t.prototype.toJSON=function(){return{keySignatures:this.keySignatures,meta:this.meta,name:this.name,ppq:this.ppq,tempos:this.tempos.map((function(t){return{bpm:t.bpm,ticks:t.ticks}})),timeSignatures:this.timeSignatures}},t.prototype.fromJSON=function(t){this.name=t.name,this.tempos=t.tempos.map((function(t){return Object.assign({},t)})),this.timeSignatures=t.timeSignatures.map((function(t){return Object.assign({},t)})),this.keySignatures=t.keySignatures.map((function(t){return Object.assign({},t)})),this.meta=t.meta.map((function(t){return Object.assign({},t)})),i.set(this,t.ppq),this.update()},t.prototype.setTempo=function(t){this.tempos=[{bpm:t,ticks:0}],this.update()},t}();e.Header=a},function(t,e,r){e.parseMidi=r(6),e.writeMidi=r(7)},function(t,e,r){"use strict";function n(t,e,r){void 0===r&&(r="ticks");var n=0,i=t.length,a=i;if(i>0&&t[i-1][r]<=e)return i-1;for(;n<a;){var o=Math.floor(n+(a-n)/2),s=t[o],c=t[o+1];if(s[r]===e){for(var u=o;u<t.length;u++){t[u][r]===e&&(o=u)}return o}if(s[r]<e&&c[r]>e)return o;s[r]>e?a=o:s[r]<e&&(n=o+1)}return-1}Object.defineProperty(e,"__esModule",{value:!0}),e.search=n,e.insert=function(t,e,r){if(void 0===r&&(r="ticks"),t.length){var i=n(t,e[r],r);t.splice(i+1,0,e)}else t.push(e)}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(2),i=r(4),a=r(10),o=r(11),s=r(12),c=r(14),u=new WeakMap,h=function(){function t(t,e){var r=this;if(this.name="",this.notes=[],this.controlChanges=a.createControlChanges(),this.pitchBends=[],u.set(this,e),t){var n=t.find((function(t){return"trackName"===t.type}));this.name=n?n.text:""}if(this.instrument=new s.Instrument(t,this),this.channel=0,t){for(var i=t.filter((function(t){return"noteOn"===t.type})),o=t.filter((function(t){return"noteOff"===t.type})),c=function(){var t=i.shift();h.channel=t.channel;var e=o.findIndex((function(e){return e.noteNumber===t.noteNumber&&e.absoluteTime>=t.absoluteTime}));if(-1!==e){var r=o.splice(e,1)[0];h.addNote({durationTicks:r.absoluteTime-t.absoluteTime,midi:t.noteNumber,noteOffVelocity:r.velocity/127,ticks:t.absoluteTime,velocity:t.velocity/127})}},h=this;i.length;)c();t.filter((function(t){return"controller"===t.type})).forEach((function(t){r.addCC({number:t.controllerType,ticks:t.absoluteTime,value:t.value/127})})),t.filter((function(t){return"pitchBend"===t.type})).forEach((function(t){r.addPitchBend({ticks:t.absoluteTime,value:t.value/Math.pow(2,13)})}));var f=t.find((function(t){return"endOfTrack"===t.type}));this.endOfTrackTicks=void 0!==f?f.absoluteTime:void 0}}return t.prototype.addNote=function(t){var e=u.get(this),r=new c.Note({midi:0,ticks:0,velocity:1},{ticks:0,velocity:0},e);return Object.assign(r,t),n.insert(this.notes,r,"ticks"),this},t.prototype.addCC=function(t){var e=u.get(this),r=new i.ControlChange({controllerType:t.number},e);return delete t.number,Object.assign(r,t),Array.isArray(this.controlChanges[r.number])||(this.controlChanges[r.number]=[]),n.insert(this.controlChanges[r.number],r,"ticks"),this},t.prototype.addPitchBend=function(t){var e=u.get(this),r=new o.PitchBend({},e);return Object.assign(r,t),n.insert(this.pitchBends,r,"ticks"),this},Object.defineProperty(t.prototype,"duration",{get:function(){if(!this.notes.length)return 0;for(var t=this.notes[this.notes.length-1].time+this.notes[this.notes.length-1].duration,e=0;e<this.notes.length-1;e++){var r=this.notes[e].time+this.notes[e].duration;t<r&&(t=r)}return t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"durationTicks",{get:function(){if(!this.notes.length)return 0;for(var t=this.notes[this.notes.length-1].ticks+this.notes[this.notes.length-1].durationTicks,e=0;e<this.notes.length-1;e++){var r=this.notes[e].ticks+this.notes[e].durationTicks;t<r&&(t=r)}return t},enumerable:!0,configurable:!0}),t.prototype.fromJSON=function(t){var e=this;for(var r in this.name=t.name,this.channel=t.channel,this.instrument=new s.Instrument(void 0,this),this.instrument.fromJSON(t.instrument),void 0!==t.endOfTrackTicks&&(this.endOfTrackTicks=t.endOfTrackTicks),t.controlChanges)t.controlChanges[r]&&t.controlChanges[r].forEach((function(t){e.addCC({number:t.number,ticks:t.ticks,value:t.value})}));t.notes.forEach((function(t){e.addNote({durationTicks:t.durationTicks,midi:t.midi,ticks:t.ticks,velocity:t.velocity})}))},t.prototype.toJSON=function(){for(var t={},e=0;e<127;e++)this.controlChanges.hasOwnProperty(e)&&(t[e]=this.controlChanges[e].map((function(t){return t.toJSON()})));var r={channel:this.channel,controlChanges:t,pitchBends:this.pitchBends.map((function(t){return t.toJSON()})),instrument:this.instrument.toJSON(),name:this.name,notes:this.notes.map((function(t){return t.toJSON()}))};return void 0!==this.endOfTrackTicks&&(r.endOfTrackTicks=this.endOfTrackTicks),r},t}();e.Track=h},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.controlChangeNames={1:"modulationWheel",2:"breath",4:"footController",5:"portamentoTime",7:"volume",8:"balance",10:"pan",64:"sustain",65:"portamentoTime",66:"sostenuto",67:"softPedal",68:"legatoFootswitch",84:"portamentoControl"},e.controlChangeIds=Object.keys(e.controlChangeNames).reduce((function(t,r){return t[e.controlChangeNames[r]]=r,t}),{});var n=new WeakMap,i=new WeakMap,a=function(){function t(t,e){n.set(this,e),i.set(this,t.controllerType),this.ticks=t.absoluteTime,this.value=t.value}return Object.defineProperty(t.prototype,"number",{get:function(){return i.get(this)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"name",{get:function(){return e.controlChangeNames[this.number]?e.controlChangeNames[this.number]:null},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"time",{get:function(){return n.get(this).ticksToSeconds(this.ticks)},set:function(t){var e=n.get(this);this.ticks=e.secondsToTicks(t)},enumerable:!0,configurable:!0}),t.prototype.toJSON=function(){return{number:this.number,ticks:this.ticks,time:this.time,value:this.value}},t}();e.ControlChange=a},function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(i,a){function o(t){try{c(n.next(t))}catch(t){a(t)}}function s(t){try{c(n.throw(t))}catch(t){a(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(o,s)}c((n=n.apply(t,e||[])).next())}))},i=this&&this.__generator||function(t,e){var r,n,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(r)throw new TypeError("Generator is already executing.");for(;o;)try{if(r=1,n&&(i=2&a[0]?n.return:a[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,a[1])).done)return i;switch(n=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,n=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=o.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=e.call(t,o)}catch(t){a=[6,t],n=0}finally{r=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}};Object.defineProperty(e,"__esModule",{value:!0});var a=r(1),o=r(8),s=r(0),c=r(3),u=function(){function t(t){var e=this,r=null;t&&(t instanceof ArrayBuffer&&(t=new Uint8Array(t)),(r=a.parseMidi(t)).tracks.forEach((function(t){var e=0;t.forEach((function(t){e+=t.deltaTime,t.absoluteTime=e}))})),r.tracks=function(t){for(var e=[],r=0;r<t.length;r++)for(var n=e.length,i=new Map,a=Array(16).fill(0),o=0,s=t[r];o<s.length;o++){var c=s[o],u=n,h=c.channel;if(void 0!==h){"programChange"===c.type&&(a[h]=c.programNumber);var f=a[h]+" "+h;i.has(f)?u=i.get(f):(u=n+i.size,i.set(f,u))}e[u]||e.push([]),e[u].push(c)}return e}(r.tracks)),this.header=new s.Header(r),this.tracks=[],t&&(this.tracks=r.tracks.map((function(t){return new c.Track(t,e.header)})),1===r.header.format&&0===this.tracks[0].duration&&this.tracks.shift())}return t.fromUrl=function(e){return n(this,void 0,void 0,(function(){var r;return i(this,(function(n){switch(n.label){case 0:return[4,fetch(e)];case 1:return(r=n.sent()).ok?[4,r.arrayBuffer()]:[3,3];case 2:return[2,new t(n.sent())];case 3:throw new Error("could not load "+e)}}))}))},Object.defineProperty(t.prototype,"name",{get:function(){return this.header.name},set:function(t){this.header.name=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"duration",{get:function(){var t=this.tracks.map((function(t){return t.duration}));return Math.max.apply(Math,t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"durationTicks",{get:function(){var t=this.tracks.map((function(t){return t.durationTicks}));return Math.max.apply(Math,t)},enumerable:!0,configurable:!0}),t.prototype.addTrack=function(){var t=new c.Track(void 0,this.header);return this.tracks.push(t),t},t.prototype.toArray=function(){return o.encode(this)},t.prototype.toJSON=function(){return{header:this.header.toJSON(),tracks:this.tracks.map((function(t){return t.toJSON()}))}},t.prototype.fromJSON=function(t){var e=this;this.header=new s.Header,this.header.fromJSON(t.header),this.tracks=t.tracks.map((function(t){var r=new c.Track(void 0,e.header);return r.fromJSON(t),r}))},t.prototype.clone=function(){var e=new t;return e.fromJSON(this.toJSON()),e},t}();e.Midi=u;var h=r(3);e.Track=h.Track;var f=r(0);e.Header=f.Header},function(t,e){function r(t){for(var e,r=new n(t),i=[];!r.eof();){var a=o();i.push(a)}return i;function o(){var t={};t.deltaTime=r.readVarInt();var n=r.readUInt8();if(240==(240&n)){if(255!==n){if(240==n){t.type="sysEx";a=r.readVarInt();return t.data=r.readBytes(a),t}if(247==n){t.type="endSysEx";a=r.readVarInt();return t.data=r.readBytes(a),t}throw"Unrecognised MIDI event type byte: "+n}t.meta=!0;var i=r.readUInt8(),a=r.readVarInt();switch(i){case 0:if(t.type="sequenceNumber",2!==a)throw"Expected length for sequenceNumber event is 2, got "+a;return t.number=r.readUInt16(),t;case 1:return t.type="text",t.text=r.readString(a),t;case 2:return t.type="copyrightNotice",t.text=r.readString(a),t;case 3:return t.type="trackName",t.text=r.readString(a),t;case 4:return t.type="instrumentName",t.text=r.readString(a),t;case 5:return t.type="lyrics",t.text=r.readString(a),t;case 6:return t.type="marker",t.text=r.readString(a),t;case 7:return t.type="cuePoint",t.text=r.readString(a),t;case 32:if(t.type="channelPrefix",1!=a)throw"Expected length for channelPrefix event is 1, got "+a;return t.channel=r.readUInt8(),t;case 33:if(t.type="portPrefix",1!=a)throw"Expected length for portPrefix event is 1, got "+a;return t.port=r.readUInt8(),t;case 47:if(t.type="endOfTrack",0!=a)throw"Expected length for endOfTrack event is 0, got "+a;return t;case 81:if(t.type="setTempo",3!=a)throw"Expected length for setTempo event is 3, got "+a;return t.microsecondsPerBeat=r.readUInt24(),t;case 84:if(t.type="smpteOffset",5!=a)throw"Expected length for smpteOffset event is 5, got "+a;var o=r.readUInt8();return t.frameRate={0:24,32:25,64:29,96:30}[96&o],t.hour=31&o,t.min=r.readUInt8(),t.sec=r.readUInt8(),t.frame=r.readUInt8(),t.subFrame=r.readUInt8(),t;case 88:if(t.type="timeSignature",4!=a)throw"Expected length for timeSignature event is 4, got "+a;return t.numerator=r.readUInt8(),t.denominator=1<<r.readUInt8(),t.metronome=r.readUInt8(),t.thirtyseconds=r.readUInt8(),t;case 89:if(t.type="keySignature",2!=a)throw"Expected length for keySignature event is 2, got "+a;return t.key=r.readInt8(),t.scale=r.readUInt8(),t;case 127:return t.type="sequencerSpecific",t.data=r.readBytes(a),t;default:return t.type="unknownMeta",t.data=r.readBytes(a),t.metatypeByte=i,t}}else{var s;if(0==(128&n)){if(null===e)throw"Running status byte encountered before status byte";s=n,n=e,t.running=!0}else s=r.readUInt8(),e=n;var c=n>>4;switch(t.channel=15&n,c){case 8:return t.type="noteOff",t.noteNumber=s,t.velocity=r.readUInt8(),t;case 9:var u=r.readUInt8();return t.type=0===u?"noteOff":"noteOn",t.noteNumber=s,t.velocity=u,0===u&&(t.byte9=!0),t;case 10:return t.type="noteAftertouch",t.noteNumber=s,t.amount=r.readUInt8(),t;case 11:return t.type="controller",t.controllerType=s,t.value=r.readUInt8(),t;case 12:return t.type="programChange",t.programNumber=s,t;case 13:return t.type="channelAftertouch",t.amount=s,t;case 14:return t.type="pitchBend",t.value=s+(r.readUInt8()<<7)-8192,t;default:throw"Unrecognised MIDI event type: "+c}}}}function n(t){this.buffer=t,this.bufferLen=this.buffer.length,this.pos=0}n.prototype.eof=function(){return this.pos>=this.bufferLen},n.prototype.readUInt8=function(){var t=this.buffer[this.pos];return this.pos+=1,t},n.prototype.readInt8=function(){var t=this.readUInt8();return 128&t?t-256:t},n.prototype.readUInt16=function(){return(this.readUInt8()<<8)+this.readUInt8()},n.prototype.readInt16=function(){var t=this.readUInt16();return 32768&t?t-65536:t},n.prototype.readUInt24=function(){return(this.readUInt8()<<16)+(this.readUInt8()<<8)+this.readUInt8()},n.prototype.readInt24=function(){var t=this.readUInt24();return 8388608&t?t-16777216:t},n.prototype.readUInt32=function(){return(this.readUInt8()<<24)+(this.readUInt8()<<16)+(this.readUInt8()<<8)+this.readUInt8()},n.prototype.readBytes=function(t){var e=this.buffer.slice(this.pos,this.pos+t);return this.pos+=t,e},n.prototype.readString=function(t){var e=this.readBytes(t);return String.fromCharCode.apply(null,e)},n.prototype.readVarInt=function(){for(var t=0;!this.eof();){var e=this.readUInt8();if(!(128&e))return t+e;t+=127&e,t<<=7}return t},n.prototype.readChunk=function(){var t=this.readString(4),e=this.readUInt32();return{id:t,length:e,data:this.readBytes(e)}},t.exports=function(t){var e=new n(t),i=e.readChunk();if("MThd"!=i.id)throw"Bad MIDI file.  Expected 'MHdr', got: '"+i.id+"'";for(var a=function(t){var e=new n(t),r=e.readUInt16(),i=e.readUInt16(),a={format:r,numTracks:i},o=e.readUInt16();32768&o?(a.framesPerSecond=256-(o>>8),a.ticksPerFrame=255&o):a.ticksPerBeat=o;return a}(i.data),o=[],s=0;!e.eof()&&s<a.numTracks;s++){var c=e.readChunk();if("MTrk"!=c.id)throw"Bad MIDI file.  Expected 'MTrk', got: '"+c.id+"'";var u=r(c.data);o.push(u)}return{header:a,tracks:o}}},function(t,e){function r(t,e,r){var a,o=new i,s=e.length,c=null;for(a=0;a<s;a++)!1!==r.running&&(r.running||e[a].running)||(c=null),c=n(o,e[a],c,r.useByte9ForNoteOff);t.writeChunk("MTrk",o.buffer)}function n(t,e,r,n){var i=e.type,a=e.deltaTime,o=e.text||"",s=e.data||[],c=null;switch(t.writeVarInt(a),i){case"sequenceNumber":t.writeUInt8(255),t.writeUInt8(0),t.writeVarInt(2),t.writeUInt16(e.number);break;case"text":t.writeUInt8(255),t.writeUInt8(1),t.writeVarInt(o.length),t.writeString(o);break;case"copyrightNotice":t.writeUInt8(255),t.writeUInt8(2),t.writeVarInt(o.length),t.writeString(o);break;case"trackName":t.writeUInt8(255),t.writeUInt8(3),t.writeVarInt(o.length),t.writeString(o);break;case"instrumentName":t.writeUInt8(255),t.writeUInt8(4),t.writeVarInt(o.length),t.writeString(o);break;case"lyrics":t.writeUInt8(255),t.writeUInt8(5),t.writeVarInt(o.length),t.writeString(o);break;case"marker":t.writeUInt8(255),t.writeUInt8(6),t.writeVarInt(o.length),t.writeString(o);break;case"cuePoint":t.writeUInt8(255),t.writeUInt8(7),t.writeVarInt(o.length),t.writeString(o);break;case"channelPrefix":t.writeUInt8(255),t.writeUInt8(32),t.writeVarInt(1),t.writeUInt8(e.channel);break;case"portPrefix":t.writeUInt8(255),t.writeUInt8(33),t.writeVarInt(1),t.writeUInt8(e.port);break;case"endOfTrack":t.writeUInt8(255),t.writeUInt8(47),t.writeVarInt(0);break;case"setTempo":t.writeUInt8(255),t.writeUInt8(81),t.writeVarInt(3),t.writeUInt24(e.microsecondsPerBeat);break;case"smpteOffset":t.writeUInt8(255),t.writeUInt8(84),t.writeVarInt(5);var u=31&e.hour|{24:0,25:32,29:64,30:96}[e.frameRate];t.writeUInt8(u),t.writeUInt8(e.min),t.writeUInt8(e.sec),t.writeUInt8(e.frame),t.writeUInt8(e.subFrame);break;case"timeSignature":t.writeUInt8(255),t.writeUInt8(88),t.writeVarInt(4),t.writeUInt8(e.numerator);var h=255&Math.floor(Math.log(e.denominator)/Math.LN2);t.writeUInt8(h),t.writeUInt8(e.metronome),t.writeUInt8(e.thirtyseconds||8);break;case"keySignature":t.writeUInt8(255),t.writeUInt8(89),t.writeVarInt(2),t.writeInt8(e.key),t.writeUInt8(e.scale);break;case"sequencerSpecific":t.writeUInt8(255),t.writeUInt8(127),t.writeVarInt(s.length),t.writeBytes(s);break;case"unknownMeta":null!=e.metatypeByte&&(t.writeUInt8(255),t.writeUInt8(e.metatypeByte),t.writeVarInt(s.length),t.writeBytes(s));break;case"sysEx":t.writeUInt8(240),t.writeVarInt(s.length),t.writeBytes(s);break;case"endSysEx":t.writeUInt8(247),t.writeVarInt(s.length),t.writeBytes(s);break;case"noteOff":(c=(!1!==n&&e.byte9||n&&0==e.velocity?144:128)|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.noteNumber),t.writeUInt8(e.velocity);break;case"noteOn":(c=144|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.noteNumber),t.writeUInt8(e.velocity);break;case"noteAftertouch":(c=160|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.noteNumber),t.writeUInt8(e.amount);break;case"controller":(c=176|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.controllerType),t.writeUInt8(e.value);break;case"programChange":(c=192|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.programNumber);break;case"channelAftertouch":(c=208|e.channel)!==r&&t.writeUInt8(c),t.writeUInt8(e.amount);break;case"pitchBend":(c=224|e.channel)!==r&&t.writeUInt8(c);var f=8192+e.value,p=127&f,l=f>>7&127;t.writeUInt8(p),t.writeUInt8(l);break;default:throw"Unrecognized event type: "+i}return c}function i(){this.buffer=[]}i.prototype.writeUInt8=function(t){this.buffer.push(255&t)},i.prototype.writeInt8=i.prototype.writeUInt8,i.prototype.writeUInt16=function(t){var e=t>>8&255,r=255&t;this.writeUInt8(e),this.writeUInt8(r)},i.prototype.writeInt16=i.prototype.writeUInt16,i.prototype.writeUInt24=function(t){var e=t>>16&255,r=t>>8&255,n=255&t;this.writeUInt8(e),this.writeUInt8(r),this.writeUInt8(n)},i.prototype.writeInt24=i.prototype.writeUInt24,i.prototype.writeUInt32=function(t){var e=t>>24&255,r=t>>16&255,n=t>>8&255,i=255&t;this.writeUInt8(e),this.writeUInt8(r),this.writeUInt8(n),this.writeUInt8(i)},i.prototype.writeInt32=i.prototype.writeUInt32,i.prototype.writeBytes=function(t){this.buffer=this.buffer.concat(Array.prototype.slice.call(t,0))},i.prototype.writeString=function(t){var e,r=t.length,n=[];for(e=0;e<r;e++)n.push(t.codePointAt(e));this.writeBytes(n)},i.prototype.writeVarInt=function(t){if(t<0)throw"Cannot write negative variable-length integer";if(t<=127)this.writeUInt8(t);else{var e=t,r=[];for(r.push(127&e),e>>=7;e;){var n=127&e|128;r.push(n),e>>=7}this.writeBytes(r.reverse())}},i.prototype.writeChunk=function(t,e){this.writeString(t),this.writeUInt32(e.length),this.writeBytes(e)},t.exports=function(t,e){if("object"!=typeof t)throw"Invalid MIDI data";e=e||{};var n,a=t.header||{},o=t.tracks||[],s=o.length,c=new i;for(function(t,e,r){var n=null==e.format?1:e.format,a=128;e.timeDivision?a=e.timeDivision:e.ticksPerFrame&&e.framesPerSecond?a=-(255&e.framesPerSecond)<<8|255&e.ticksPerFrame:e.ticksPerBeat&&(a=32767&e.ticksPerBeat);var o=new i;o.writeUInt16(n),o.writeUInt16(r),o.writeUInt16(a),t.writeChunk("MThd",o.buffer)}(c,a,s),n=0;n<s;n++)r(c,o[n],e);return c.buffer}},function(t,e,r){"use strict";var n=this&&this.__spreadArrays||function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),i=0;for(e=0;e<r;e++)for(var a=arguments[e],o=0,s=a.length;o<s;o++,i++)n[i]=a[o];return n},i=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});var a=r(1),o=r(0),s=i(r(9));function c(t){return s.default(t.notes.map((function(e){return function(t,e){return[{absoluteTime:t.ticks,channel:e,deltaTime:0,noteNumber:t.midi,type:"noteOn",velocity:Math.floor(127*t.velocity)},{absoluteTime:t.ticks+t.durationTicks,channel:e,deltaTime:0,noteNumber:t.midi,type:"noteOff",velocity:Math.floor(127*t.noteOffVelocity)}]}(e,t.channel)})))}function u(t,e){return{absoluteTime:t.ticks,channel:e,controllerType:t.number,deltaTime:0,type:"controller",value:Math.floor(127*t.value)}}function h(t){return{absoluteTime:0,channel:t.channel,deltaTime:0,programNumber:t.instrument.number,type:"programChange"}}e.encode=function(t){var e={header:{format:1,numTracks:t.tracks.length+1,ticksPerBeat:t.header.ppq},tracks:n([n([{absoluteTime:0,deltaTime:0,meta:!0,text:t.header.name,type:"trackName"}],t.header.keySignatures.map((function(t){return function(t){var e=o.keySignatureKeys.indexOf(t.key);return{absoluteTime:t.ticks,deltaTime:0,key:e+7,meta:!0,scale:"major"===t.scale?0:1,type:"keySignature"}}(t)})),t.header.meta.map((function(t){return{absoluteTime:(e=t).ticks,deltaTime:0,meta:!0,text:e.text,type:e.type};var e})),t.header.tempos.map((function(t){return function(t){return{absoluteTime:t.ticks,deltaTime:0,meta:!0,microsecondsPerBeat:Math.floor(6e7/t.bpm),type:"setTempo"}}(t)})),t.header.timeSignatures.map((function(t){return function(t){return{absoluteTime:t.ticks,deltaTime:0,denominator:t.timeSignature[1],meta:!0,metronome:24,numerator:t.timeSignature[0],thirtyseconds:8,type:"timeSignature"}}(t)})))],t.tracks.map((function(t){return n([(e=t.name,{absoluteTime:0,deltaTime:0,meta:!0,text:e,type:"trackName"}),h(t)],c(t),function(t){for(var e=[],r=0;r<127;r++)t.controlChanges.hasOwnProperty(r)&&t.controlChanges[r].forEach((function(r){e.push(u(r,t.channel))}));return e}(t),function(t){var e=[];return t.pitchBends.forEach((function(r){e.push(function(t,e){return{absoluteTime:t.ticks,channel:e,deltaTime:0,type:"pitchBend",value:t.value}}(r,t.channel))})),e}(t));var e})))};return e.tracks=e.tracks.map((function(t){t=t.sort((function(t,e){return t.absoluteTime-e.absoluteTime}));var e=0;return t.forEach((function(t){t.deltaTime=t.absoluteTime-e,e=t.absoluteTime,delete t.absoluteTime})),t.push({deltaTime:0,meta:!0,type:"endOfTrack"}),t})),new Uint8Array(a.writeMidi(e))}},function(t,e,r){"use strict";function n(t){return function t(e,r){for(var n=0;n<e.length;n++){var i=e[n];Array.isArray(i)?t(i,r):r.push(i)}return r}(t,[])}function i(t,e){if("number"!=typeof e)throw new TypeError("Expected the depth to be a number");return function t(e,r,n){n--;for(var i=0;i<e.length;i++){var a=e[i];n>-1&&Array.isArray(a)?t(a,r,n):r.push(a)}return r}(t,[],e)}t.exports=function(t){if(!Array.isArray(t))throw new TypeError("Expected value to be an array");return n(t)},t.exports.from=n,t.exports.depth=function(t,e){if(!Array.isArray(t))throw new TypeError("Expected value to be an array");return i(t,e)},t.exports.fromDepth=i},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(4);e.createControlChanges=function(){return new Proxy({},{get:function(t,e){return t[e]?t[e]:n.controlChangeIds.hasOwnProperty(e)?t[n.controlChangeIds[e]]:void 0},set:function(t,e,r){return n.controlChangeIds.hasOwnProperty(e)?t[n.controlChangeIds[e]]=r:t[e]=r,!0}})}},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=new WeakMap,i=function(){function t(t,e){n.set(this,e),this.ticks=t.absoluteTime,this.value=t.value}return Object.defineProperty(t.prototype,"time",{get:function(){return n.get(this).ticksToSeconds(this.ticks)},set:function(t){var e=n.get(this);this.ticks=e.secondsToTicks(t)},enumerable:!0,configurable:!0}),t.prototype.toJSON=function(){return{ticks:this.ticks,time:this.time,value:this.value}},t}();e.PitchBend=i},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=r(13),i=new WeakMap,a=function(){function t(t,e){if(this.number=0,i.set(this,e),this.number=0,t){var r=t.find((function(t){return"programChange"===t.type}));r&&(this.number=r.programNumber)}}return Object.defineProperty(t.prototype,"name",{get:function(){return this.percussion?n.DrumKitByPatchID[this.number]:n.instrumentByPatchID[this.number]},set:function(t){var e=n.instrumentByPatchID.indexOf(t);-1!==e&&(this.number=e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"family",{get:function(){return this.percussion?"drums":n.InstrumentFamilyByID[Math.floor(this.number/8)]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"percussion",{get:function(){return 9===i.get(this).channel},enumerable:!0,configurable:!0}),t.prototype.toJSON=function(){return{family:this.family,name:this.name,number:this.number}},t.prototype.fromJSON=function(t){this.number=t.number},t}();e.Instrument=a},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.instrumentByPatchID=["acoustic grand piano","bright acoustic piano","electric grand piano","honky-tonk piano","electric piano 1","electric piano 2","harpsichord","clavi","celesta","glockenspiel","music box","vibraphone","marimba","xylophone","tubular bells","dulcimer","drawbar organ","percussive organ","rock organ","church organ","reed organ","accordion","harmonica","tango accordion","acoustic guitar (nylon)","acoustic guitar (steel)","electric guitar (jazz)","electric guitar (clean)","electric guitar (muted)","overdriven guitar","distortion guitar","guitar harmonics","acoustic bass","electric bass (finger)","electric bass (pick)","fretless bass","slap bass 1","slap bass 2","synth bass 1","synth bass 2","violin","viola","cello","contrabass","tremolo strings","pizzicato strings","orchestral harp","timpani","string ensemble 1","string ensemble 2","synthstrings 1","synthstrings 2","choir aahs","voice oohs","synth voice","orchestra hit","trumpet","trombone","tuba","muted trumpet","french horn","brass section","synthbrass 1","synthbrass 2","soprano sax","alto sax","tenor sax","baritone sax","oboe","english horn","bassoon","clarinet","piccolo","flute","recorder","pan flute","blown bottle","shakuhachi","whistle","ocarina","lead 1 (square)","lead 2 (sawtooth)","lead 3 (calliope)","lead 4 (chiff)","lead 5 (charang)","lead 6 (voice)","lead 7 (fifths)","lead 8 (bass + lead)","pad 1 (new age)","pad 2 (warm)","pad 3 (polysynth)","pad 4 (choir)","pad 5 (bowed)","pad 6 (metallic)","pad 7 (halo)","pad 8 (sweep)","fx 1 (rain)","fx 2 (soundtrack)","fx 3 (crystal)","fx 4 (atmosphere)","fx 5 (brightness)","fx 6 (goblins)","fx 7 (echoes)","fx 8 (sci-fi)","sitar","banjo","shamisen","koto","kalimba","bag pipe","fiddle","shanai","tinkle bell","agogo","steel drums","woodblock","taiko drum","melodic tom","synth drum","reverse cymbal","guitar fret noise","breath noise","seashore","bird tweet","telephone ring","helicopter","applause","gunshot"],e.InstrumentFamilyByID=["piano","chromatic percussion","organ","guitar","bass","strings","ensemble","brass","reed","pipe","synth lead","synth pad","synth effects","world","percussive","sound effects"],e.DrumKitByPatchID={0:"standard kit",8:"room kit",16:"power kit",24:"electronic kit",25:"tr-808 kit",32:"jazz kit",40:"brush kit",48:"orchestra kit",56:"sound fx kit"}},function(t,e,r){"use strict";function n(t){return["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][t%12]}Object.defineProperty(e,"__esModule",{value:!0});var i,a,o=(i=/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,a={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},function(t){var e=i.exec(t),r=e[1],n=e[2];return a[r.toLowerCase()]+12*(parseInt(n,10)+1)}),s=new WeakMap,c=function(){function t(t,e,r){s.set(this,r),this.midi=t.midi,this.velocity=t.velocity,this.noteOffVelocity=e.velocity,this.ticks=t.ticks,this.durationTicks=e.ticks-t.ticks}return Object.defineProperty(t.prototype,"name",{get:function(){return t=this.midi,e=Math.floor(t/12)-1,n(t)+e.toString();var t,e},set:function(t){this.midi=o(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"octave",{get:function(){return Math.floor(this.midi/12)-1},set:function(t){var e=t-this.octave;this.midi+=12*e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"pitch",{get:function(){return n(this.midi)},set:function(t){this.midi=12*(this.octave+1)+["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"].indexOf(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"duration",{get:function(){var t=s.get(this);return t.ticksToSeconds(this.ticks+this.durationTicks)-t.ticksToSeconds(this.ticks)},set:function(t){var e=s.get(this).secondsToTicks(this.time+t);this.durationTicks=e-this.ticks},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"time",{get:function(){return s.get(this).ticksToSeconds(this.ticks)},set:function(t){var e=s.get(this);this.ticks=e.secondsToTicks(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"bars",{get:function(){return s.get(this).ticksToMeasures(this.ticks)},enumerable:!0,configurable:!0}),t.prototype.toJSON=function(){return{duration:this.duration,durationTicks:this.durationTicks,midi:this.midi,name:this.name,ticks:this.ticks,time:this.time,velocity:this.velocity}},t}();e.Note=c}])}));
    </script>
    <style>
        /* =========================================
           V9.3 Theme: Global Heritage (Dark & Gold)
           ========================================= */
        body { 
            font-family: 'Biz UDPGothic', 'Meiryo', sans-serif; 
            background: #121212; 
            color: #e0e0e0; 
            padding: 20px; 
            line-height: 1.6; 
        }
        .container { 
            max-width: 1000px; 
            margin: 0 auto; 
            background: #1e1e1e; 
            padding: 30px; 
            border-radius: 8px; 
            box-shadow: 0 15px 50px rgba(0,0,0,0.9); 
            border-top: 4px solid #ffd700;
            position: relative;
        }
        
        /* Header & Lang Switch */
        header {
            display: flex; justify-content: space-between; align-items: flex-start;
            border-bottom: 1px solid #444; padding-bottom: 15px; margin-bottom: 25px; 
        }
        h1 { 
            margin: 0; color: #fff; font-size: 22px; letter-spacing: 1px; 
        }
        h1 span { 
            font-size: 0.6em; background: #ffd700; color: #000; 
            font-weight:800; padding: 3px 8px; border-radius: 2px; 
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            margin-left: 10px;
        }
        .header-btns {
            display: flex; gap: 10px; align-items: center;
        }
        .lang-btn {
            background: #333; color: #ccc; border: 1px solid #555;
            padding: 5px 10px; cursor: pointer; font-size: 12px; border-radius: 4px;
        }
        .lang-btn:hover { background: #444; color: #fff; }

        /* --- MODE TABS (NEW) --- */
        .mode-tabs {
            display: flex; background: #333; border-radius: 4px; padding: 2px; margin-right: 10px;
        }
        .tab-btn {
            border: none; background: transparent; color: #aaa;
            padding: 6px 12px; cursor: pointer; font-weight: bold; border-radius: 3px;
            transition: 0.2s; font-size: 12px;
        }
        .tab-btn.active {
            background: #ffd700; color: #000; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .tab-btn:hover:not(.active) { color: #fff; background: #444; }

        /* Quick Start */
        .quick-start {
            background: #252526; border: 1px dashed #555; padding: 15px;
            margin-bottom: 20px; font-size: 0.9em; color: #bbb;
        }
        .quick-start h3 { margin-top: 0; font-size: 1em; color: #ffd700; margin-bottom: 8px; }
        .quick-start ol { margin: 0; padding-left: 20px; }
        .quick-start li { margin-bottom: 4px; }

        /* Controls */
        .controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .controls-row2 { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 20px; }
        
        label { display: block; font-weight: bold; margin-bottom: 8px; color: #aaa; font-size: 0.75em; text-transform: uppercase; letter-spacing: 0.05em; }
        .highlight-label { color: #ffd700; }

        input, select { 
            width: 100%; padding: 10px; box-sizing: border-box;
            background: #2d2d2d; border: 1px solid #444; 
            color: white; border-radius: 4px; font-size: 14px;
        }
        input:focus, select:focus { border-color: #ffd700; outline: none; background: #333; }

        /* --- FIXED STANDARD SLIDER STYLING --- */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none; /* ★これを追加 */
            width: 100%; height: 6px; 
            background: #444; border-radius: 3px; outline: none; margin: 10px 0; cursor: pointer; border: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px; border-radius: 50%; background: #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor: pointer; border: none; margin-top: -1px;
        }
        input[type=range]::-moz-range-thumb {
            width: 16px; height: 16px; border: none; border-radius: 50%;
            background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor: pointer;
        }
        /* Disabled state for sliders */
        input[type=range]:disabled { opacity: 0.3; cursor: not-allowed; }

        /* --- TOGGLE SWITCH (NEW) --- */
        .toggle-switch {
            position: relative; display: inline-block; width: 40px; height: 20px; vertical-align: middle;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider-sw {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #444; transition: .4s; border-radius: 20px;
        }
        .slider-sw:before {
            position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider-sw { background-color: #ffd700; }
        input:checked + .slider-sw:before { transform: translateX(20px); }

        /* Mixer Panel */
        .mixer-panel {
            background: #252526; border: 1px solid #333;
            border-radius: 6px; padding: 20px; margin-bottom: 25px;
            display: none; /* Initially hidden */
        }
        .mixer-header {
            font-size: 0.85em; color: #aaa; border-bottom: 1px solid #444; 
            padding-bottom: 8px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;
        }
        .btn-reset {
            background: #444; color: #fff; border: none; padding: 4px 10px;
            font-size: 0.8em; cursor: pointer; border-radius: 3px;
        }
        .btn-reset:hover { background: #666; }

        /* Mixer Channels (Standard) */
        .mixer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;}
        .channel-strip {
            background: #1a1a1a; padding: 15px; border-radius: 4px;
            border-top: 3px solid #555; text-align: center;
        }
        .ch-melody { border-top-color: #ff4081; } 
        .ch-bass   { border-top-color: #00e5ff; } 
        .ch-acc    { border-top-color: #ffd740; } 
        
        .role-tag {
            display: inline-block; font-size: 0.7em; padding: 2px 8px; border-radius: 20px;
            color: #121212; font-weight: 800; margin-bottom: 12px;
        }
        .tag-melody { background: #ff4081; }
        .tag-bass   { background: #00e5ff; }
        .tag-acc    { background: #ffd740; }
        
        .param-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.75em; color: #ccc; margin-bottom: 5px; }
        select.mini-select { padding: 2px 4px; font-size: 11px; width: auto; background: #222; border: 1px solid #555; height: 24px; }

        /* PRO Mode Panel Styles */
        #proPanel {
            display: none; background: #252526; 
            border-radius: 6px; margin-bottom: 20px; border-left: 4px solid #00e5ff;
            padding: 10px;
        }
        .pro-track-row {
            display: grid; 
            grid-template-columns: 30px 2fr 100px 60px 80px 80px; 
            gap: 10px; 
            align-items: center;
            background: #1a1a1a; 
            padding: 8px; 
            border-radius: 4px; 
            border-left: 3px solid #555;
            font-size: 0.85em;
            margin-bottom: 4px;
        }
        .pro-track-row.editing { border-left-color: #ffd700; background: #333; }
        .pro-track-row.muted { opacity: 0.5; }
        
        .prio-select { background:#222; color:#fff; border:1px solid #444; padding:2px; font-size:0.8em; height: 24px;}
        .btn-mini { padding: 4px 8px; font-size: 10px; cursor: pointer; border-radius: 3px; border:none; color:#fff;}
        .btn-edit { background: #444; }
        .btn-edit.active { background: #ffd700; color:#000; font-weight:bold; }

        /* Extended Mixer Controls */
        .mixer-extended {
            display: grid; grid-template-columns: 1fr 2fr; gap: 20px;
            background: #1a1a1a; padding: 15px; border-radius: 4px; border: 1px solid #333;
        }
        
        /* --- TRIMMING UI --- */
        .trim-container {
            position: relative;
            width: 100%; height: 60px;
            background: #000; border: 1px solid #444; border-radius: 4px;
            overflow: hidden; margin-top: 10px; user-select: none;
        }
        canvas#trimCanvas { width: 100%; height: 100%; display: block; }
        /* Edit Mode Cursor */
        canvas#trimCanvas.edit-mode { cursor: crosshair; }

        .trim-handle {
            position: absolute; top: 0; bottom: 0; width: 16px; 
            background: rgba(255, 215, 0, 0.8); cursor: ew-resize; z-index: 10;
            display: flex; align-items: center; justify-content: center;
        }
        .trim-handle::after { content:'||'; color: #000; font-size: 10px; font-weight: bold; }
        .trim-handle-l { left: 0; border-radius: 4px 0 0 4px; border-right: 1px solid #fff; }
        .trim-handle-r { right: 0; border-radius: 0 4px 4px 0; border-left: 1px solid #fff; }
        
        .trim-mask {
            position: absolute; top:0; bottom:0; background: rgba(0,0,0,0.7); z-index: 5;
        }
        .trim-mask-l { left: 0; width: 0; border-right: 1px solid #ffd700; }
        .trim-mask-r { right: 0; width: 0; border-left: 1px solid #ffd700; }

        .time-labels { display: flex; justify-content: space-between; font-size: 0.75em; color: #ffd700; margin-top: 4px; font-family: monospace; }

        /* Transport */
        .transport {
            margin-top: 20px; display: grid; grid-template-columns: 100px 100px 1fr; gap: 15px; align-items: center;
        }
        .btn-sim { 
            padding: 10px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; color: #fff; 
            text-transform: uppercase; font-size: 0.8em; letter-spacing: 0.5px;
        }
        .btn-play { background: #2e7d32; } .btn-play:hover { background: #4caf50; }
        .btn-stop { background: #c62828; } .btn-stop:hover { background: #ef5350; }

        .progress-container { height: 6px; background: #111; border-radius: 3px; overflow: hidden; position: relative; }
        .progress-bar { width: 0%; height: 100%; background: #ffd700; transition: width 0.1s linear; }

        /* Action Buttons */
        .action-area { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px; display:none; }
        .btn-main { 
            background: linear-gradient(135deg, #d32f2f, #b71c1c); color: white; 
            padding: 15px; border: none; border-radius: 4px; 
            width: 100%; font-size: 15px; font-weight: bold; cursor: pointer; 
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .btn-main:hover { background: linear-gradient(135deg, #e53935, #c62828); transform: translateY(-1px); }
        .btn-export { background: linear-gradient(135deg, #1976d2, #0d47a1); }
        .btn-export:hover { background: linear-gradient(135deg, #2196f3, #1565c0); transform: translateY(-1px); }

        /* Report & Code */
        .stats-panel {
            background: #202020; border-left: 5px solid #ffd700;
            padding: 20px; margin-top: 25px; margin-bottom: 25px;
            display: none; border-radius: 0 4px 4px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .report-title { font-weight: bold; font-size: 1.1em; margin-bottom: 12px; color: #e0e0e0; display:flex; align-items:center;}
        .report-title::before { content: '■'; color: #ffd700; margin-right: 8px; font-size: 0.8em; }
        .report-row { margin-bottom: 6px; font-size: 0.95em; color: #ccc; }
        .report-label { color: #aaa; margin-right: 5px; }

        pre { 
            background: #000; color: #00e676; 
            padding: 20px; border-radius: 4px; overflow-x: auto; height: 300px; 
            border: 1px solid #333; font-family: 'Consolas', monospace; font-size: 13px; display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>MIDI ArduinoIDE <span>PRO V9.3</span></h1>
        <div class="header-btns">
            <div class="mode-tabs">
                <button id="tabStd" class="tab-btn active" onclick="setMode('Standard')">STANDARD</button>
                <button id="tabPro" class="tab-btn" onclick="setMode('Pro')">PRO MODE</button>
            </div>
            <button class="lang-btn" onclick="toggleLanguage()" id="btnLang">English</button>
        </div>
    </header>

    <div class="quick-start">
        <h3 id="qsTitle">QUICK START</h3>
        <ol>
            <li id="qs1">Select a MIDI file (or use the loaded sample).</li>
            <li id="qs2">Adjust settings (Volume, Tuning, Trim).</li>
            <li id="qs3">Check with [PLAY] and click [GENERATE SKETCH].</li>
        </ol>
    </div>
    
    <div class="controls">
        <div>
            <label id="lblMidi">1. MIDI File (.mid)</label>
            <input type="file" id="midiInput" accept=".mid,.midi">
        </div>
        <div>
            <label id="lblTarget">2. Target & Engine</label>
            <div style="display:flex; gap:5px;">
                <select id="mcuSelect" onchange="toggleEngineUI(); updateLiveVoices()" style="flex:1;">
                    <option value="R4">Arduino UNO R4</option>
                    <option value="R3">Arduino UNO R3 (12-Voice 1-bit)</option>
                    <option value="ESP32">ESP32 (High Fidelity)</option>
                    <option value="Pico">Raspberry Pi Pico (RP2040)</option>
                    <option value="Pico2">Raspberry Pi Pico 2 (RP2350)</option>
                </select>
                <select id="engineSelect" onchange="toggleEngineUI(); updateLiveVoices()" style="flex:1; display:none;">
                    <option value="PWM">PWM (Poly + Vol)</option>
                    <option value="1BIT">1-bit (Retro/Solid)</option>
                </select>
            </div>
        </div>
        <div>
            <label id="lblVoice">3. Voices (Pins)</label>
            <div style="display:flex; justify-content:space-between; color:#ffd700; font-size:0.8em; margin-bottom:2px;">
                <span id="voiceCountDisp">8</span>
            </div>
            <input type="range" id="voiceCount" min="1" max="12" value="8" step="1" oninput="updateVoiceLimit(); updateSliderFill(this, '#ffd700');">
        </div>
    </div>
    
    <div class="controls-row2">
        <div>
            <label class="highlight-label" id="lblTuning">4. Global Tuning / Scale Mode</label>
            <select id="tuningSelect" onchange="updateLiveVoices()">
                <optgroup label="--- Standard ---">
                    <option value="12TET" selected>12-TET (Standard Average)</option>
                </optgroup>
                <optgroup label="1. Western History & Classical">
                    <option value="Pythagorean">Pythagorean (5ths)</option>
                    <option value="Just">Just Intonation (Pure Major)</option>
                    <option value="Meantone">Meantone (1/4 Comma)</option>
                    <option value="Werckmeister">Werckmeister III (Bach)</option>
                    <option value="Kirnberger">Kirnberger III (Beethoven)</option>
                    <option value="Vallotti">Vallotti (Baroque Standard)</option>
                    <option value="Young">Young (Well Temperament)</option>
                </optgroup>
                <optgroup label="2. Asia & Ethnic">
                    <option value="Miyako">Miyako-Bushi (Japan/Gloomy)</option>
                    <option value="Ryukyu">Ryukyu (Okinawa/Bright)</option>
                    <option value="Minchao">Min-chao (China Pentatonic)</option>
                    <option value="Arabic">Arabic (Maqam Rast / Microtone)</option>
                    <option value="Slendro">Slendro (Gamelan 5)</option>
                    <option value="Pelog">Pelog (Gamelan 7)</option>
                </optgroup>
                <optgroup label="3. Modern & Experimental">
                    <option value="19TET">19-TET (19 Tone/Oct)</option>
                    <option value="31TET">31-TET (31 Tone/Oct)</option>
                    <option value="WholeTone">Whole Tone (Dreamy)</option>
                    <option value="BlueNote">Blue Note (Jazz/Blues)</option>
                    <option value="Detuned">Detuned 8-bit (Retro/Wobbly)</option>
                    <option value="Dorian">Dorian Mode (Medieval/RPG)</option>
                </optgroup>
            </select>
        </div>
        <div>
        </div>
    </div>

    <div id="mixerPanel" class="mixer-panel">
        <div class="mixer-header">
            <span style="font-weight:bold; color:#fff;" id="hdrMixer">REALTIME MIXER & EDITOR</span>
            <div>
                <span id="trackInfoStatus" style="margin-right:15px; font-size:0.9em;"></span>
                <button class="btn-reset" onclick="resetMixerSettings()" id="btnReset">RESET SETTINGS</button>
            </div>
        </div>
        
        <div class="mixer-grid" id="standardMixer">
            <div class="channel-strip ch-melody">
                <span class="role-tag tag-melody">MELODY</span>
                <div class="param-row">
                    <span id="lblVolMelody">Vol: <span id="dispMelody">150%</span></span>
                    <select id="octMelody" class="mini-select" onchange="updateLiveVoices()">
                        <option value="36">+3 Oct</option>
                        <option value="24">+2 Oct</option>
                        <option value="12" selected>+1 Oct</option>
                        <option value="0">±0</option>
                        <option value="-12">-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                    </select>
                </div>
                <div id="wrapVolMelody" style="display:block;">
                    <input type="range" id="volMelody" min="0" max="600" value="150" oninput="updateLiveVoices('Melody'); updateSliderFill(this, '#ff4081');">
                </div>
                <div id="wrapSwMelody" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swMelody" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>
            
            <div class="channel-strip ch-bass">
                <span class="role-tag tag-bass">BASS</span>
                <div class="param-row">
                    <span id="lblVolBass">Vol: <span id="dispBass">100%</span></span>
                    <select id="octBass" class="mini-select" onchange="updateLiveVoices()">
                        <option value="12">+1 Oct</option>
                        <option value="0">±0</option>
                        <option value="-12" selected>-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                        <option value="-36">-3 Oct</option>
                    </select>
                </div>
                <div id="wrapVolBass" style="display:block;">
                    <input type="range" id="volBass" min="0" max="600" value="100" oninput="updateLiveVoices('Bass'); updateSliderFill(this, '#00e5ff');">
                </div>
                <div id="wrapSwBass" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swBass" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>

            <div class="channel-strip ch-acc">
                <span class="role-tag tag-acc">BACKING</span>
                <div class="param-row">
                    <span id="lblVolAcc">Vol: <span id="dispAcc">70%</span></span>
                    <select id="octAcc" class="mini-select" onchange="updateLiveVoices()">
                        <option value="24">+2 Oct</option>
                        <option value="12">+1 Oct</option>
                        <option value="0" selected>±0</option>
                        <option value="-12">-1 Oct</option>
                        <option value="-24">-2 Oct</option>
                    </select>
                </div>
                <div id="wrapVolAcc" style="display:block;">
                    <input type="range" id="volAcc" min="0" max="600" value="70" oninput="updateLiveVoices('Acc'); updateSliderFill(this, '#ffd740');">
                </div>
                <div id="wrapSwAcc" style="display:none; margin-top:10px;">
                    <label class="toggle-switch">
                        <input type="checkbox" id="swAcc" checked onchange="updateLiveVoices()">
                        <span class="slider-sw round"></span>
                    </label>
                    <span style="font-size:0.8em; font-weight:bold; margin-left:5px;">ACTIVE</span>
                </div>
            </div>
        </div>

        <div id="proPanel">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h3 style="margin:0; color:#00e5ff; font-size:1em;">PRO TRACK MANAGER</h3>
                <label style="color:#e0e0e0; font-size:0.9em; cursor:pointer; display:flex; align-items:center;">
                    <input type="checkbox" id="chkFixedMax" onchange="generateReportAndCode(true)" style="width:auto; margin-right:5px;"> 
                    <span id="lblFixedMax">Fixed Max Vol (Ignore Velocity)</span>
                </label>
            </div>
            <div style="display:grid; grid-template-columns: 30px 2fr 100px 60px 80px 80px; gap:10px; color:#888; font-size:0.7em; margin-bottom:5px; padding:0 10px;">
                <span>#</span><span>Track Name</span><span>Vol</span><span>Oct</span><span>Priority</span><span>Action</span>
            </div>
            <div id="proTrackList" style="max-height:300px; overflow-y:auto;"></div>
        </div>

        <div class="mixer-extended">
            <div style="text-align:center;">
                <label style="color:#fff;" id="lblSpeed">PLAYBACK SPEED</label>
                <div style="color:#ffd700; font-weight:bold; font-size:1.2em; margin:5px 0;" id="speedDisplay">x 1.0</div>
                <input type="range" id="speedRange" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateSpeed(); updateSliderFill(this, '#ffd700');">
            </div>

            <div>
                <label style="color:#fff; display:flex; justify-content:space-between; margin-bottom:10px;">
                    <span id="lblRange">TRIMMING (MIDI TIMELINE)</span>
                    <span id="lblEditHint" style="font-size:0.8em; color:#ffd700; display:none;">* Edit Mode: Click note to Mute/Unmute</span>
                </label>
                
                <div class="trim-container" id="trimContainer">
                    <canvas id="trimCanvas"></canvas>
                    <div class="trim-mask trim-mask-l" id="trimMaskL"></div>
                    <div class="trim-mask trim-mask-r" id="trimMaskR"></div>
                    <div class="trim-handle trim-handle-l" id="trimHandleL"></div>
                    <div class="trim-handle trim-handle-r" id="trimHandleR"></div>
                </div>

                <div class="time-labels">
                    <span id="dispStart">0:00</span>
                    <span id="dispEnd">0:00</span>
                </div>
                <div style="font-size:0.75em; color:#666; margin-top:5px; text-align:right;" id="lblRangeNote">
                    * Output will be shifted to start at 0s.
                </div>
            </div>
        </div>

        <div class="transport">
            <button class="btn-sim btn-play" onclick="startSimulation()" id="btnPlay">PLAY</button>
            <button class="btn-sim btn-stop" onclick="stopSimulation()" id="btnStop">STOP</button>
            <div>
                <div class="progress-container">
                    <div id="progressBar" class="progress-bar"></div>
                </div>
                <div style="text-align:right; font-size:0.75em; color:#888; margin-top:4px; font-family:monospace;">
                    <span id="timeDisplay">0:00 / 0:00</span>
                </div>
            </div>
        </div>
    </div>

    <div id="actionArea" class="action-area">
        <button class="btn-main" onclick="generateReportAndCode()" id="btnGen">GENERATE SKETCH</button>
        <button class="btn-main btn-export" onclick="exportModifiedMidi()" id="btnExp">EXPORT MIDI (.mid)</button>
    </div>
    
    <div id="statsPanel" class="stats-panel"></div>

    <pre id="codeDisplay"></pre>
</div>

<script>
// ==========================================
// Language Dictionary (JP/EN)
// ==========================================
const LANG = {
    ja: {
        qsTitle: "操作方法",
        qs1: "MIDIファイルを選択（または自動ロードされたサンプルを使用）",
        qs2: "設定を調整 (音量, 音律, トリミング)",
        qs3: "[再生]で確認し、[スケッチ生成]をクリック",
        lblMidi: "1. MIDIファイル (.mid)",
        lblTarget: "2. ターゲット & エンジン",
        lblVoice: "3. パッシブブザー数 (ピン数)",
        lblTuning: "4. 音律 / スケールモード",
        hdrMixer: "リアルタイム・ミキサー (設定 & 調整)",
        btnReset: "設定リセット",
        lblSpeed: "再生速度",
        lblRange: "トリミング (MIDIタイムライン)",
        lblStart: "開始",
        lblEnd: "終了",
        lblRangeNote: "* 出力時、開始位置は0秒に詰められます。",
        btnPlay: "再生 (プレビュー)",
        btnStop: "停止",
        btnGen: "スケッチ生成 (C++)",
        btnExp: "MIDI書き出し (.mid)",
        btnLang: "English",
        trackInfo: "トラック数",
        events: "イベント数",
        reportTitle: "スケッチレポート",
        dropRate: "脱落率",
        pins: "使用ピン",
        target: "ターゲット",
        system: "音律システム"
    },
    en: {
        qsTitle: "How to use",
        qs1: "Select a MIDI file (or use loaded sample)",
        qs2: "Adjust settings (Vol, Tuning, Trim)",
        qs3: "Check with [PLAY] and click [GENERATE SKETCH]",
        lblMidi: "1. MIDI File (.mid)",
        lblTarget: "2. Target & Engine",
        lblVoice: "3. Passive Buzzers (Pins)",
        lblTuning: "4. Global Tuning / Scale Mode",
        hdrMixer: "REALTIME MIXER & EDITOR",
        btnReset: "RESET SETTINGS",
        lblSpeed: "PLAYBACK SPEED",
        lblRange: "TRIMMING (MIDI TIMELINE)",
        lblStart: "START",
        lblEnd: "END",
        lblRangeNote: "* Output starts at 0s (Time Shifted).",
        btnPlay: "PLAY (PREVIEW)",
        btnStop: "STOP",
        btnGen: "GENERATE SKETCH",
        btnExp: "EXPORT MIDI (.mid)",
        btnLang: "日本語",
        trackInfo: "Tracks",
        events: "Events",
        reportTitle: "Generation Report",
        dropRate: "Drop Rate",
        pins: "Pins",
        target: "Target",
        system: "Tuning System"
    }
};
let currentLang = 'ja';

function toggleLanguage() {
    currentLang = (currentLang === 'ja') ? 'en' : 'ja';
    updateLanguageUI();
    if(document.getElementById('statsPanel').style.display === 'block') {
        generateReportAndCode(true); 
    }
}

function updateLanguageUI() {
    const t = LANG[currentLang];
    const setText = (id, txt) => { if(document.getElementById(id)) document.getElementById(id).innerText = txt; };
    
    setText('qsTitle', t.qsTitle);
    setText('qs1', t.qs1);
    setText('qs2', t.qs2);
    setText('qs3', t.qs3);
    setText('lblMidi', t.lblMidi);
    setText('lblTarget', t.lblTarget);
    setText('lblVoice', t.lblVoice);
    setText('lblTuning', t.lblTuning);
    // Dynamic Header
    if(gMode === 'Standard') setText('hdrMixer', t.hdrMixer);
    else if(document.getElementById('hdrMixer')) document.getElementById('hdrMixer').innerText = "PRO MIXER & EDITOR";

    setText('btnReset', t.btnReset);
    setText('lblSpeed', t.lblSpeed);
    setText('lblRange', t.lblRange);
    setText('lblRangeNote', t.lblRangeNote);
    setText('btnPlay', t.btnPlay);
    setText('btnStop', t.btnStop);
    setText('btnGen', t.btnGen);
    setText('btnExp', t.btnExp);
    setText('btnLang', t.btnLang);

    if(gMidi) {
        document.getElementById('trackInfoStatus').innerText = `${t.trackInfo}: ${gMidi.tracks.length} / ${t.events}: ${gRawEvents.length}`;
    }
}

// ==========================================
// V7: グローバル音律データ定義
// ==========================================
const TUNING_DEFS = {
    "12TET":        { type: "offset", val: [0,0,0,0,0,0,0,0,0,0,0,0] },
    "Pythagorean":  { type: "offset", val: [-6, 8, -2, 12, 2, -8, 6, -4, 10, 0, -10, 4] },
    "Just":         { type: "offset", val: [16, -14, 20, 31, 2, 14, -16, 18, 29, 0, 12, 4] },
    "Meantone":     { type: "offset", val: [0, -24, -7, 10, -14, 3, -21, -3, -27, -10, 7, -17] },
    "Werckmeister": { type: "offset", val: [12, 2, 4, 6, 2, 10, 0, 8, 4, 0, 8, 4] },
    "Kirnberger":   { type: "offset", val: [10, 1, 3, 4, -4, 8, -2, 7, 2, 0, 6, -2] },
    "Vallotti":     { type: "offset", val: [6, 0, 2, 4, -2, 8, -2, 4, 2, 0, 6, -4] },
    "Young":        { type: "offset", val: [6, 0, 2, 4, -2, 8, -2, 4, 2, 0, 6, -4] },
    "Arabic":       { type: "offset", val: [0, 0, -50, 0, -50, 0, 0, 0, 0, -50, 0, -50] },

    "Miyako":       { type: "map", val: [0, 1, 1, 1, 5, 5, 5, 7, 8, 8, 8, 0] },
    "Ryukyu":       { type: "map", val: [0, 0, 4, 4, 4, 5, 5, 7, 7, 7, 11, 11] },
    "Minchao":      { type: "map", val: [0, 0, 2, 2, 4, 4, 4, 7, 7, 9, 9, 9] },
    "Slendro":      { type: "map", val: [0, 0, 2, 2, 5, 5, 5, 7, 7, 9, 9, 0] },
    "Pelog":        { type: "map", val: [0, 1, 1, 3, 3, 5, 5, 7, 8, 8, 10, 10] },
    "WholeTone":    { type: "map", val: [0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10] },
    "BlueNote":     { type: "map", val: [0, 0, 0, 3, 3, 5, 6, 7, 7, 7, 10, 10] },
    "Dorian":       { type: "map", val: [0, 0, 2, 3, 3, 5, 5, 7, 7, 9, 10, 10] },

    "19TET":        { type: "math", div: 19 },
    "31TET":        { type: "math", div: 31 },
    "Detuned":      { type: "special", mode: "wobbly" }
};

// ==========================================
// グローバル変数
// ==========================================
let gMidi = null;      
let gTrackRoles = [];
let gRawEvents = []; // {t, type, p, v, dur, role, trackIdx}
let gFilename = "Sample_Morning.mid"; 

let audioCtx = null;
let isPlaying = false;
let scheduleInterval = null;
let uiInterval = null;
let startTime = 0;
let nextNoteIndex = 0;
let totalDuration = 0;
let activeVoices = []; 

// V7.1 State
let gSpeed = 1.0;
let gRangeStart = 0;
let gRangeEnd = 0;

// V8.0 PRO Mode State
let gMode = 'Standard'; // 'Standard' or 'Pro'
let gProSettings = [];  // Array of {vol, oct, prio, mute, name}
let gEditingTrack = -1; // -1:None, >=0: TrackIdx

const PIN_MAP = {
    ESP32: [32, 33, 27, 4, 5, 18, 19, 21, 22, 23, 13, 12], 
    R4:    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
    R3:    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14], // 14=A0
    // Pico & Pico 2: GP0-GP28 (GP23/24/25/29等は内部用の場合があるが、ここでは物理ピンを最大列挙)
    Pico:  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,26,27,28, 23,24,25],
    Pico2: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,26,27,28, 23,24,25]
};

// ==========================================
// UI Utils & Mode Switching
// ==========================================
function updateSliderFill(el, color) {
    const min = el.min ? parseFloat(el.min) : 0;
    const max = el.max ? parseFloat(el.max) : 100;
    const val = parseFloat(el.value);
    const ratio = (val - min) / (max - min);
    const stopPosition = `calc(${ratio * 100}% + (${8 - ratio * 16}px))`;
    el.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${stopPosition}, #444 ${stopPosition}, #444 100%)`;
}

// 修正: エンジン選択UIの表示制御と、スライダーの数値・見た目の完全同期
function toggleEngineUI() {
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect');
    const vc = document.getElementById('voiceCount');
    const vcDisp = document.getElementById('voiceCountDisp');
    
    // 1. エンジン選択肢 (PWM vs 1BIT) を表示するマイコン
    const hasDualMode = (mcu === 'R4' || mcu === 'Pico' || mcu === 'Pico2');
    eng.style.display = hasDualMode ? 'block' : 'none';
    
    // 2. ピン数スライダーの上限設定
    let newMax = 12;
    // Pico系はGPIOが多いので最大28まで許可
    if(mcu === 'Pico' || mcu === 'Pico2') {
        newMax = 28;
    }

    // 上限値を適用
    vc.max = newMax;

    // 3. 現在の値が上限を超えていないかチェックし、補正する
    let currentVal = parseInt(vc.value);
    if(currentVal > newMax) {
        currentVal = newMax;
        vc.value = newMax; // 値を強制的に下げる
    }

    // 4. 表示と内部状態を更新
    vcDisp.innerText = currentVal;
    
    // ★修正点: 値が変わった(または上限が変わった)ので、スライダーの「塗り」を強制更新する
    updateSliderFill(vc, '#ffd700');
    
    // ボイス制限の適用（あふれたボイスを停止）
    updateVoiceLimit(); 
    
    // 5. 1-bitモード判定 (UIの出し分け)
    const is1Bit = (mcu === 'R3') || (hasDualMode && eng.value === '1BIT');

    // --- Standard Mode UI制御 ---
    ['Melody', 'Bass', 'Acc'].forEach(role => {
        const wrapVol = document.getElementById('wrapVol' + role);
        const wrapSw = document.getElementById('wrapSw' + role);
        const lbl = document.getElementById('lblVol' + role);
        const disp = document.getElementById('disp' + role);
        const slider = document.getElementById('vol' + role);

        if(is1Bit) {
            // 1-bit: スライダー隠す、スイッチ出す
            if(wrapVol) wrapVol.style.display = 'none';
            if(wrapSw) wrapSw.style.display = 'block';
            if(lbl) lbl.innerHTML = "STATUS: "; 
        } else {
            // PWM: スライダー出す、スイッチ隠す
            if(wrapVol) wrapVol.style.display = 'block';
            if(wrapSw) wrapSw.style.display = 'none';
            if(lbl) lbl.innerHTML = "Vol: <span id='disp"+role+"'>"+slider.value+"%</span>";
        }
    });

    // --- Pro Mode UI制御 ---
    if(gMode === 'Pro') {
        initProTrackList();
    }
}

// 修正: 新しいモード切替
function setMode(mode) {
    gMode = mode;
    
    // タブの見た目更新
    document.getElementById('tabStd').className = (mode === 'Standard') ? 'tab-btn active' : 'tab-btn';
    document.getElementById('tabPro').className = (mode === 'Pro') ? 'tab-btn active' : 'tab-btn';

    // パネル表示切替
    const mixerStd = document.getElementById('standardMixer');
    const proPanel = document.getElementById('proPanel');
    const mixerHdr = document.getElementById('hdrMixer');

    if(gMode === 'Pro') {
        proPanel.style.display = 'block';
        mixerStd.style.display = 'none';
        if(mixerHdr) mixerHdr.innerText = "PRO MIXER & EDITOR";
        initProTrackList();
    } else {
        proPanel.style.display = 'none';
        mixerStd.style.display = 'grid';
        if(mixerHdr) mixerHdr.innerText = "REALTIME MIXER & EDITOR";
        gEditingTrack = -1;
        initTrimmer(); 
    }
    
    // UI状態（1bitかPWMか）を再評価して表示を更新
    toggleEngineUI();
}

// ==========================================
// 1. SAMPLE MIDI GENERATOR
// ==========================================
function createSampleMidi() {
    // Helper to write variable length quantity
    const vlq = (v) => {
        let b=[]; let x=v;
        do { b.unshift(x&0x7f); x>>=7; } while(x>0);
        for(let i=0; i<b.length-1; i++) b[i]|=0x80;
        return b;
    };
    
    // Minimal Track Writer
    const createTrack = (notes, ch) => {
        let data = [];
        let lastT = 0;
        notes.forEach(n => {
            let dt = n.t - lastT;
            data.push(...vlq(dt));
            data.push(0x90|ch, n.p, 100); // Note On
            lastT = n.t;
            
            dt = n.d;
            data.push(...vlq(dt));
            data.push(0x80|ch, n.p, 0); // Note Off
            lastT += dt;
        });
        data.push(0x00, 0xFF, 0x2F, 0x00);
        const len = data.length;
        return [0x4D, 0x54, 0x72, 0x6B, (len>>24)&0xFF, (len>>16)&0xFF, (len>>8)&0xFF, len&0xFF, ...data];
    };

    // Composition: "Morning Glory"
    let trMelody = [];
    let trBass = [];
    let trAcc = [];
    
    [0, 480*4].forEach(offset => {
        [60, 64, 67, 72, 67, 64].forEach((p, i) => {
            trMelody.push({t: offset + i*480, d: 400, p: p});
        });
        trMelody.push({t: offset + 6*480, d: 800, p: 76}); 
        
        trBass.push({t: offset, d: 480*2, p: 36}); 
        trBass.push({t: offset + 480*2, d: 480*2, p: 43}); 
        trBass.push({t: offset + 480*4, d: 480*2, p: 41}); 
        trBass.push({t: offset + 480*6, d: 480*2, p: 43}); 

        for(let k=0; k<8; k++){
            trAcc.push({t: offset + k*480, d: 100, p: 60}); 
            trAcc.push({t: offset + k*480 + 240, d: 100, p: 64}); 
        }
    });

    const header = [0x4D, 0x54, 0x68, 0x64, 0,0,0,6, 0,1, 0,3, 0x01, 0xE0]; 
    const t1 = createTrack(trMelody, 0);
    const t2 = createTrack(trBass, 1);
    const t3 = createTrack(trAcc, 2);
    
    return new Uint8Array([...header, ...t1, ...t2, ...t3]);
}

// ==========================================
// 2. MIDI Loading & Parsing 
// ==========================================
async function loadMidiData(arrayBuffer, name) {
    try {
        gFilename = name;
        gMidi = new Midi(arrayBuffer);
        const stats = analyzeTracks(gMidi);
        gTrackRoles = classifyTracks(stats);
        gRawEvents = extractRawEvents(gMidi, gTrackRoles);
        
        // 曲の全長を更新
        totalDuration = gMidi.duration;
        
        
        gRangeStart = 0;
        gRangeEnd = totalDuration;
        
        // Reset Pro Settings
        gProSettings = [];
        gEditingTrack = -1;

        initTrimmer(); 
        
        stopSimulation();
        document.getElementById('mixerPanel').style.display = 'block';
        document.getElementById('actionArea').style.display = 'grid';
        updateLanguageUI();
        
        if(gMode === 'Pro') initProTrackList();
        updateLiveVoices();

    } catch(err) {
        alert("Error: " + err);
        console.error(err);
    }
}

// Initial Load
window.onload = () => {
    const sampleBytes = createSampleMidi();
    loadMidiData(sampleBytes.buffer, "Sample_Morning.mid");
    
    updateSliderFill(document.getElementById('voiceCount'), '#ffd700');
    updateSliderFill(document.getElementById('volMelody'), '#ff4081');
    updateSliderFill(document.getElementById('volBass'), '#00e5ff');
    updateSliderFill(document.getElementById('volAcc'), '#ffd740');
    updateSliderFill(document.getElementById('speedRange'), '#ffd700');
    
    toggleEngineUI(); // Init State
};

document.getElementById('midiInput').addEventListener('change', async (e) => {
    if(!e.target.files[0]) return;
    const reader = new FileReader();
    reader.onload = async (ev) => loadMidiData(ev.target.result, e.target.files[0].name);
    reader.readAsArrayBuffer(e.target.files[0]);
});

function updateLiveVoices(triggerRole) {
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && engine === '1BIT');

    if(triggerRole && triggerRole !== 'Limit' && gMode==='Standard' && !is1Bit) {
        const val = document.getElementById('vol' + triggerRole).value;
        document.getElementById('disp' + triggerRole).innerText = val + "%";
    }
    if(isPlaying && activeVoices.length > 0) {
        applyLiveParams();
    }
}

function updateVoiceLimit() {
    const val = document.getElementById('voiceCount').value;
    document.getElementById('voiceCountDisp').innerText = val;
    // Remove excess voices
    while(activeVoices.length > val) {
        // Simple removal (PRO logic will handle better stealing later)
        const victim = activeVoices.shift();
        if(victim) try { victim.osc.stop(audioCtx.currentTime); } catch(e){}
    }
}

function updateSpeed() {
    const newSpeed = parseFloat(document.getElementById('speedRange').value);
    document.getElementById('speedDisplay').innerText = "x " + newSpeed.toFixed(1);
    
    if(isPlaying && audioCtx) {
        const now = audioCtx.currentTime;
        const elapsed = now - startTime;
        const currentSongPos = elapsed * gSpeed;
        gSpeed = newSpeed;
        startTime = now - (currentSongPos / gSpeed);
    } else {
        gSpeed = newSpeed;
    }
}

// ==========================================
// 3. PRO Mode UI Functions
// ==========================================
function initProTrackList() {
    const container = document.getElementById('proTrackList');
    container.innerHTML = "";
    
    // 1-bit判定
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && eng.value === '1BIT');
    
    // Initialize if empty
    if(gProSettings.length !== gMidi.tracks.length) {
        gProSettings = gMidi.tracks.map((t, i) => {
            // Auto Priority based on Role
            let prio = 'Mid';
            if(gTrackRoles[i] === 'melody') prio = 'High';
            if(gTrackRoles[i] === 'acc') prio = 'Low';
            
            return {
                vol: 100,
                oct: 0,
                prio: prio,
                mute: false,
                name: t.name || `Track ${i+1}`
            };
        });
    }

    gProSettings.forEach((s, i) => {
        const div = document.createElement('div');
        div.className = `pro-track-row ${s.mute ? 'muted' : ''}`;
        if(gEditingTrack === i) div.classList.add('editing');
        
        // 1-bit時はボリュームスライダーを表示しない
        const volDisplay = is1Bit ? 'visibility:hidden;' : '';

        div.innerHTML = `
            <span style="color:#aaa;">#${i+1}</span>
            <div style="overflow:hidden; white-space:nowrap; text-overflow:ellipsis;" title="${s.name}">${s.name}</div>
            
            <input type="range" min="0" max="200" value="${s.vol}" style="height:4px; ${volDisplay}" 
                oninput="gProSettings[${i}].vol=this.value; updateLiveVoices();">
            
            <select class="prio-select" onchange="gProSettings[${i}].oct=parseInt(this.value); updateLiveVoices();">
                <option value="12" ${s.oct===12?'selected':''}>+1</option>
                <option value="0" ${s.oct===0?'selected':''}>0</option>
                <option value="-12" ${s.oct===-12?'selected':''}>-1</option>
                <option value="-24" ${s.oct===-24?'selected':''}>-2</option>
            </select>

            <select class="prio-select" onchange="gProSettings[${i}].prio=this.value;">
                <option value="High" ${s.prio==='High'?'selected':''}>Hi</option>
                <option value="Mid" ${s.prio==='Mid'?'selected':''}>Mid</option>
                <option value="Low" ${s.prio==='Low'?'selected':''}>Lo</option>
            </select>

            <div style="display:flex; gap:2px;">
                <button class="btn-mini btn-edit ${gEditingTrack===i?'active':''}" onclick="setEditTrack(${i})">EDIT</button>
                <button class="btn-mini" style="background:${s.mute?'#d32f2f':'#444'}" onclick="toggleMute(${i})">${s.mute?'OFF':'ON'}</button>
            </div>
        `;
        container.appendChild(div);
    });
}

function toggleMute(idx) {
    gProSettings[idx].mute = !gProSettings[idx].mute;
    initProTrackList();
    updateLiveVoices(); // Stops muted voices
}

function setEditTrack(idx) {
    if(gEditingTrack === idx) gEditingTrack = -1; 
    else gEditingTrack = idx;
    initProTrackList();
    initTrimmer(); // Redraw canvas with ghosting
}

// ==========================================
// 4. Visual Trimmer & Editor Implementation
// ==========================================
function initTrimmer() {
    gRangeStart = Math.max(0, gRangeStart);
    gRangeEnd = Math.min(totalDuration, gRangeEnd);
    if(gRangeEnd <= gRangeStart) gRangeEnd = totalDuration;

    const container = document.getElementById('trimContainer');
    const canvas = document.getElementById('trimCanvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;

    // Draw Background
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Edit Mode Hint
    const hint = document.getElementById('lblEditHint');
    hint.style.display = (gMode === 'Pro' && gEditingTrack !== -1) ? 'inline' : 'none';
    if(gMode === 'Pro' && gEditingTrack !== -1) canvas.classList.add('edit-mode');
    else canvas.classList.remove('edit-mode');

    // Draw MIDI Notes
    gRawEvents.forEach(e => {
        if(e.type !== 1) return;
        
        let alpha = 1.0;
        let color = '#fff';
        
        if(gMode === 'Pro' && gEditingTrack !== -1) {
            // Edit Mode: Ghost others
            if(e.trackIdx !== gEditingTrack) {
                alpha = 0.2;
                color = '#888';
            } else {
                // Active Track
                color = (e.v === 0) ? '#444' : '#ffd700'; // Muted (deleted) notes are dark
            }
        } else {
            // Standard/Overview Mode
            color = e.role === 'melody' ? '#ff4081' : (e.role === 'bass' ? '#00e5ff' : '#ffd740');
        }

        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        
        const x = (e.t / totalDuration) * canvas.width;
        const w = Math.max(2, (e.dur / totalDuration) * canvas.width);
        const y = canvas.height - ((e.p / 128) * canvas.height);
        
        ctx.fillRect(x, y - 2, w, 4);
    });
    ctx.globalAlpha = 1.0;

    updateTrimUI();
    setupTrimInteractions();
}

function updateTrimUI() {
    const L = document.getElementById('trimHandleL');
    const R = document.getElementById('trimHandleR');
    const ML = document.getElementById('trimMaskL');
    const MR = document.getElementById('trimMaskR');
    
    const pctL = (gRangeStart / totalDuration) * 100;
    const pctR = (gRangeEnd / totalDuration) * 100;

    L.style.left = pctL + "%";
    R.style.left = pctR + "%";
    ML.style.width = pctL + "%";
    MR.style.width = (100 - pctR) + "%";
    
    document.getElementById('dispStart').innerText = formatTime(gRangeStart);
    document.getElementById('dispEnd').innerText = formatTime(gRangeEnd);
}

function setupTrimInteractions() {
    const con = document.getElementById('trimContainer');
    const L = document.getElementById('trimHandleL');
    const R = document.getElementById('trimHandleR');
    const canvas = document.getElementById('trimCanvas');
    let dragging = null;

    // Canvas Click (Edit Mode)
    canvas.onclick = (e) => {
        if(gMode === 'Pro' && gEditingTrack !== -1) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const t = (x / rect.width) * totalDuration;
            const p = 128 - (y / rect.height) * 128;
            
            // Find note
            const marginT = totalDuration * 0.01; 
            const found = gRawEvents.find(ev => 
                ev.trackIdx === gEditingTrack && ev.type === 1 &&
                t >= ev.t - marginT && t <= ev.t + ev.dur + marginT &&
                Math.abs(ev.p - p) < 5
            );
            
            if(found) {
                // Toggle Mute (Set Velocity to 0 or Restore)
                if(found.v === 0) found.v = found.originalV || 100;
                else { found.originalV = found.v; found.v = 0; }
                initTrimmer(); // Redraw
            }
        }
    };

    // Trim Handles
    const onMove = (e) => {
        if(!dragging) return;
        const rect = con.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let x = clientX - rect.left;
        let pct = Math.max(0, Math.min(1, x / rect.width));
        let t = pct * totalDuration;

        if(dragging === 'L') {
            if(t < gRangeEnd - 0.5) gRangeStart = t;
        } else {
            if(t > gRangeStart + 0.5) gRangeEnd = t;
        }
        updateTrimUI();
        if(isPlaying) stopSimulation();
    };

    const onEnd = () => { dragging = null; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onEnd); };

    L.addEventListener('mousedown', (e) => { e.stopPropagation(); dragging = 'L'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd); });
    R.addEventListener('mousedown', (e) => { e.stopPropagation(); dragging = 'R'; window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd); });
    
    L.addEventListener('touchstart', (e) => { e.stopPropagation(); dragging = 'L'; });
    R.addEventListener('touchstart', (e) => { e.stopPropagation(); dragging = 'R'; });
    con.addEventListener('touchmove', onMove);
    con.addEventListener('touchend', () => dragging = null);
}

function resetMixerSettings() {
    if(!confirm("Reset all settings?")) return;
    
    // Reset Standard
    ['Melody','Bass','Acc'].forEach(role => {
        const defV = (role==='Melody')?150:(role==='Bass'?100:70);
        const color = (role==='Melody')?'#ff4081':(role==='Bass'?'#00e5ff':'#ffd740');
        const el = document.getElementById('vol'+role);
        el.value = defV;
        updateSliderFill(el, color);
        document.getElementById('disp'+role).innerText = defV + "%";
        // Reset Switch
        const sw = document.getElementById('sw'+role);
        if(sw) sw.checked = true;
    });
    document.getElementById('octMelody').value = "12";
    document.getElementById('octBass').value = "-12";
    document.getElementById('octAcc').value = "0";
    
    // Reset Common
    document.getElementById('tuningSelect').value = "12TET";
    const spd = document.getElementById('speedRange');
    spd.value = "1.0";
    updateSliderFill(spd, '#ffd700');
    gSpeed = 1.0;
    document.getElementById('speedDisplay').innerText = "x 1.0";

    gRangeStart = 0; gRangeEnd = totalDuration;
    
    // Reset Pro
    gProSettings = []; // Will regenerate on next open
    if(gMode === 'Pro') initProTrackList();

    updateTrimUI();
    const vc = document.getElementById('voiceCount');
    vc.value = 8;
    updateSliderFill(vc, '#ffd700');
    updateVoiceLimit();
    toggleEngineUI();
}


// ==========================================
// 5. Sound Engine (Priority & Resource Optimization)
// ==========================================
function getFrequency(midiNote, modeName) {
    if (midiNote < 0) midiNote = 0; if (midiNote > 127) midiNote = 127;
    const baseFreq = 440;
    const def = TUNING_DEFS[modeName] || TUNING_DEFS["12TET"];
    
    if (def.type === "map") {
        const octave = Math.floor(midiNote / 12);
        const noteIdx = midiNote % 12;
        const mappedIdx = def.val[noteIdx];
        midiNote = (octave * 12) + mappedIdx;
        return baseFreq * Math.pow(2, (midiNote - 69) / 12);
    }
    if (def.type === "offset") {
        const noteIdx = midiNote % 12;
        const semitoneOffset = def.val[noteIdx] / 100.0;
        return baseFreq * Math.pow(2, (midiNote - 69 + semitoneOffset) / 12);
    }
    if (def.type === "math") {
        return baseFreq * Math.pow(2, ((midiNote - 69) * (def.div / 12.0)) / def.div);
    }
    if (def.type === "special") {
        const standard = baseFreq * Math.pow(2, (midiNote - 69) / 12);
        return standard * (1.0 + (Math.random() * 0.02 - 0.01));
    }
    return baseFreq * Math.pow(2, (midiNote - 69) / 12);
}

function applyLiveParams() {
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const tuningMode = document.getElementById('tuningSelect').value;
    const ctxTime = audioCtx.currentTime;
    
    const hasDualMode = (mcu === 'R4' || mcu === 'Pico' || mcu === 'Pico2');
    const is1Bit = (mcu === 'R3') || (hasDualMode && engine === '1BIT');

    activeVoices.forEach(voice => {
        let vol = 1.0;
        let pOffset = 0;
        let isMuted = false;

        if(gMode === 'Standard') {
            const mix = {
                melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
                bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
                acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
            };
            const s = mix[voice.role];
            
            if (is1Bit) {
                const sw = document.getElementById('sw' + voice.role.charAt(0).toUpperCase() + voice.role.slice(1));
                if (sw && !sw.checked) isMuted = true;
                vol = 1.0;
            } else {
                vol = s.v;
            }
            pOffset = s.p;
        } else {
            const s = gProSettings[voice.trackIdx];
            if(s.mute) isMuted = true;
            else vol = is1Bit ? 1.0 : s.vol / 100;
            pOffset = s.oct;
        }

        if(isMuted || vol <= 0) {
            voice.gain.gain.setTargetAtTime(0, ctxTime, 0.05);
            return;
        }

        const targetPitch = voice.baseMidi + pOffset;
        let freq = getFrequency(targetPitch, tuningMode);
        
        if(!is1Bit && (mcu === 'R4' || mcu === 'Pico' || mcu === 'Pico2') && voice.role === 'bass') {
            voice.osc.type = 'sawtooth';
        } else {
            voice.osc.type = 'square';
        }
        
        voice.osc.frequency.setTargetAtTime(freq, ctxTime, 0.05);

        // ★修正点: 音量計算 (playNoteと合わせる)
        let targetVol = 0;
        if(is1Bit) {
            targetVol = 0.1;
        } else {
            // PWM時は大きくする (0.2倍)
            targetVol = voice.baseVel * vol * 0.2;
        }

        if(voice.role === 'acc') targetVol *= 0.6;
        
        targetVol = Math.min(0.5, targetVol); 
        voice.gain.gain.setTargetAtTime(targetVol, ctxTime, 0.05);
    });
}

function stopSimulation() {
    isPlaying = false;
    if(scheduleInterval) clearInterval(scheduleInterval);
    if(uiInterval) clearInterval(uiInterval);
    if(audioCtx) try { audioCtx.close(); } catch(e){}
    audioCtx = null;
    activeVoices = [];
    document.getElementById('progressBar').style.width = "0%";
}

function startSimulation() {
    stopSimulation();
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    if (audioCtx.state === 'suspended') audioCtx.resume();

    isPlaying = true;
    startTime = audioCtx.currentTime + 0.1;
    
    nextNoteIndex = 0;
    while(nextNoteIndex < gRawEvents.length && gRawEvents[nextNoteIndex].t < gRangeStart) {
        nextNoteIndex++;
    }

    scheduleInterval = setInterval(() => {
        if(!isPlaying) return;
        const now = audioCtx.currentTime;
        const elapsed = now - startTime;
        const currentSongTime = (elapsed * gSpeed) + gRangeStart; 
        const lookAhead = 0.1 * gSpeed;

        while(nextNoteIndex < gRawEvents.length) {
            const ev = gRawEvents[nextNoteIndex];
            if(ev.t > currentSongTime + lookAhead) break;
            if(ev.t > gRangeEnd) {
                nextNoteIndex = gRawEvents.length; 
                break;
            }

            const timeUntilEvent = (ev.t - currentSongTime) / gSpeed;
            const playTime = now + timeUntilEvent;
            
            if(playTime >= now) {
                playNote(ev, playTime);
            }
            nextNoteIndex++;
        }
        
        const durationPlayed = (gRangeEnd - gRangeStart) / gSpeed;
        if(elapsed > durationPlayed + 0.5) {
            stopSimulation();
        }
    }, 25);

    uiInterval = setInterval(() => {
        if(!isPlaying) return;
        const elapsed = audioCtx.currentTime - startTime;
        const totalPlayable = (gRangeEnd - gRangeStart) / gSpeed;
        
        const pct = Math.min(100, (elapsed / totalPlayable) * 100);
        document.getElementById('progressBar').style.width = pct + "%";
        
        const currentSongT = Math.min(gRangeEnd, gRangeStart + (elapsed * gSpeed));
        document.getElementById('timeDisplay').innerText = 
            formatTime(currentSongT) + " / " + formatTime(totalDuration) + " (x" + gSpeed.toFixed(1) + ")";

        activeVoices = activeVoices.filter(v => v.endTime > audioCtx.currentTime);
    }, 100);
}

function playNote(ev, time) {
    if(ev.type !== 1) return;
    if(ev.v === 0) return; // Mute/Deleted notes skip

    // 1. 設定値の取得 (Standard/PRO共通)
    let vol = 1.0;
    let pOffset = 0;
    let priority = 1; // 0:Low, 1:Mid, 2:High
    let isMuted = false;
    
    // Check Engine Mode
    const mcu = document.getElementById('mcuSelect').value;
    const engine = document.getElementById('engineSelect').value;
    const hasDualMode = (mcu === 'R4' || mcu === 'Pico' || mcu === 'Pico2');
    const is1Bit = (mcu === 'R3') || (hasDualMode && engine === '1BIT');

    if(gMode === 'Standard') {
        const mix = {
            melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
            bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
            acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
        };
        const s = mix[ev.role];
        
        if (is1Bit) {
            const sw = document.getElementById('sw' + ev.role.charAt(0).toUpperCase() + ev.role.slice(1));
            if (sw && !sw.checked) isMuted = true;
            vol = 1.0;
        } else {
            vol = s.v;
        }
        pOffset = s.p;
        if(ev.role === 'melody') priority = 2;
        else if(ev.role === 'bass') priority = 1;
        else priority = 0;
    } else {
        // PRO Mode
        const s = gProSettings[ev.trackIdx];
        if(s.mute) isMuted = true;
        vol = is1Bit ? 1.0 : s.vol / 100;
        pOffset = s.oct;
        
        if(s.prio === 'High') priority = 2;
        else if(s.prio === 'Low') priority = 0;
        else priority = 1; 
    }

    if(isMuted) return; 
    if(!is1Bit && vol <= 0) return; 

    // 2. ボイス割り当て
    const maxVoices = parseInt(document.getElementById('voiceCount').value);
    
    if (activeVoices.length >= maxVoices) {
        activeVoices.sort((a, b) => {
            if(a.priority !== b.priority) return a.priority - b.priority;
            return a.startTime - b.startTime;
        });
        const victim = activeVoices[0]; 
        if(priority >= victim.priority) {
            try { victim.osc.stop(time); } catch(e){}
            activeVoices.shift(); 
        } else {
            return; 
        }
    }

    // 3. 発音処理
    const tuningMode = document.getElementById('tuningSelect').value;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    const pitch = ev.p + pOffset;
    osc.frequency.value = getFrequency(pitch, tuningMode);
    
    // 波形選択: R4/PicoのPWMモードでBassならSawtooth、それ以外はSquare
    if(!is1Bit && (mcu === 'R4' || mcu === 'Pico' || mcu === 'Pico2') && ev.role === 'bass') {
        osc.type = 'sawtooth';
    } else {
        osc.type = 'square';
    }
    
    // ▼▼▼ 修正箇所ここから ▼▼▼
    
    // PWMモード（R3以外）の基本音量を 0.05 から 0.2 に引き上げ
    // これにより、R3（1-bit）の音量感に近づきます
    let finalVol = ev.v * vol * 0.2; 

    if(ev.role === 'acc') finalVol *= 0.6;
    
    // 1-bitモード（R3など）は固定で 0.1 のまま（これが基準）
    if(is1Bit) finalVol = 0.1; 

    // Pico/Pico2専用の条件分岐は削除しました
    // (上記の 0.2倍 への変更ですべてのPWMマイコンの音が大きくなるため不要です)

    // ▲▲▲ 修正箇所ここまで ▲▲▲

    gain.gain.value = Math.min(0.5, finalVol); // Clip防止のリミッター

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.start(time);
    const noteDur = ev.dur / gSpeed;
    const endTime = time + noteDur;
    osc.stop(endTime);

    activeVoices.push({
        osc: osc, gain: gain, role: ev.role, trackIdx: ev.trackIdx,
        baseMidi: ev.p, baseVel: ev.v, endTime: endTime,
        priority: priority, startTime: time
    });
}

// ==========================================
// 6. Code Generation & Export (Optimized)
// ==========================================
function getCookedEvents() {
    const tuningMode = document.getElementById('tuningSelect').value;
    const def = TUNING_DEFS[tuningMode] || TUNING_DEFS["12TET"];
    
    // Check global fixed max
    const fixedMax = (gMode === 'Pro' && document.getElementById('chkFixedMax').checked);
    
    // Check Engine Mode for Mute Logic
    const mcu = document.getElementById('mcuSelect').value;
    const eng = document.getElementById('engineSelect').value;
    const is1Bit = (mcu === 'R3') || (mcu === 'R4' && eng.value === '1BIT');

    let cookedEvents = [];
    let idCount = 0;
    
    gMidi.tracks.forEach((t, i) => {
        // Determine Track Settings
        let vol, oct, prio;
        let role = gTrackRoles[i]; 
        let isMuted = false;

        if(gMode === 'Standard') {
            const mix = {
                melody: { v: parseInt(document.getElementById('volMelody').value)/100, p: parseInt(document.getElementById('octMelody').value) },
                bass:   { v: parseInt(document.getElementById('volBass').value)/100,   p: parseInt(document.getElementById('octBass').value) },
                acc:    { v: parseInt(document.getElementById('volAcc').value)/100,    p: parseInt(document.getElementById('octAcc').value) }
            };
            const s = mix[role];
            
            if (is1Bit) {
                // スイッチ状態を確認 (Standard Mode 1-bit)
                const sw = document.getElementById('sw' + role.charAt(0).toUpperCase() + role.slice(1));
                if (sw && !sw.checked) isMuted = true;
                vol = 1.0;
            } else {
                vol = s.v;
            }
            oct = s.p;
            prio = (role==='melody')?2:(role==='bass'?1:0);
        } else {
            // Pro Mode
            const s = gProSettings[i];
            if(s.mute) isMuted = true;
            vol = s.vol / 100;
            oct = s.oct;
            prio = (s.prio==='High')?2:(s.prio==='Low'?0:1);
        }

        // --- メモリ節約ロジック ---
        // ミュートされている、または(PWMモードで)音量が0以下の場合はデータを生成しない
        if (isMuted || (!is1Bit && vol <= 0)) return;

        t.notes.forEach(n => {
            if(n.time < gRangeStart || n.time > gRangeEnd) return;
            if(n.duration < 0.01) return;
            
            const shiftedStart = (n.time - gRangeStart) / gSpeed;
            const shiftedDur = n.duration / gSpeed;
            
            let p = n.midi + oct;
            if(def.type === "map") {
                const octave = Math.floor(p / 12);
                const noteIdx = p % 12;
                const mappedIdx = def.val[noteIdx];
                p = (octave * 12) + mappedIdx;
            }

            let v = 0;
            if(fixedMax) {
                v = 255; 
            } else {
                let rawV = n.velocity * 127 * vol; 
                v = Math.round(rawV);
                if(v > 250) v = 250; 
            }
            
            p = Math.max(0, Math.min(127, Math.round(p)));
            
            const id = idCount++;
            cookedEvents.push({t: Math.round(shiftedStart*1000), type:1, p:p, v:v, id:id, prio:prio});
            cookedEvents.push({t: Math.round((shiftedStart+shiftedDur)*1000), type:0, p:p, v:0, id:id, prio:prio});
        });
    });
    return cookedEvents.sort((a,b) => (a.t===b.t) ? a.type-b.type : a.t-b.t);
}

function generateReportAndCode(onlyTextUpdate = false) {
    if(!gMidi) return;
    const vCount = parseInt(document.getElementById('voiceCount').value);
    const mcu = document.getElementById('mcuSelect').value;
    const tuningMode = document.getElementById('tuningSelect').value;
    
    const stats = document.getElementById('statsPanel');
    if(onlyTextUpdate && stats.style.display === 'none') return;

    const cookedEvents = getCookedEvents();
    // Simulate with priority logic
    const result = simulateAllocation(cookedEvents, vCount);
    const pins = PIN_MAP[mcu].slice(0, vCount);
    // Correct pin display for R3 A0
    if(mcu === 'R3' && vCount >= 12) pins[11] = "A0";

    const lang = LANG[currentLang];
    
    const dropRate = ((result.dropped / (cookedEvents.length/2)) * 100).toFixed(1);
    
    stats.style.display = 'block';
    stats.innerHTML = `
        <div class="report-title">${lang.reportTitle}</div>
        <div class="report-row"><span class="report-label">${lang.target}:</span> ${mcu} / ${vCount} Voices</div>
        <div class="report-row"><span class="report-label">${lang.system}:</span> <span style="color:#ffd700">${tuningMode}</span></div>
        <div class="report-row"><span class="report-label">Mode:</span> ${gMode}</div>
        <div class="report-row"><span class="report-label">${lang.events}:</span> ${result.events.length}</div>
        <div class="report-row"><span class="report-label">${lang.dropRate}:</span> <span style="color:${parseFloat(dropRate)>5?'#ff5252':'#ffab40'}">${result.dropped} (${dropRate}%)</span></div>
        <div class="report-row" style="font-size:0.8em; margin-top:8px; color:#666;">${lang.pins}: ${pins.join(", ")}</div>
    `;

    if(!onlyTextUpdate) {
        const code = generateSketch(mcu, result.events, vCount, tuningMode);
        const pre = document.getElementById('codeDisplay');
        pre.style.display = 'block';
        pre.textContent = code;
        navigator.clipboard.writeText(code).then(() => alert("Code Copied!"));
    }
}

function exportModifiedMidi() {
    if(!gMidi) return;
    const writeVarLen = (val) => {
        if (val === 0) return [0x00];
        const bytes = [];
        let v = val;
        while (v > 0) {
            bytes.unshift(v & 0x7F);
            v >>= 7;
        }
        for (let i = 0; i < bytes.length - 1; i++) bytes[i] |= 0x80;
        return bytes;
    }

    const events = getCookedEvents();
    let trackData = [];
    let lastT = 0;
    trackData.push(0x00, 0xC0, 80); 

    events.forEach(e => {
        let delta = e.t - lastT;
        if (delta < 0) delta = 0;
        lastT = e.t;
        const dBytes = writeVarLen(delta);
        trackData.push(...dBytes);
        if(e.type === 1) { 
            let v = Math.min(127, e.v);
            trackData.push(0x90, e.p, v);
        } else { 
            trackData.push(0x80, e.p, 0);
        }
    });
    trackData.push(0x00, 0xFF, 0x2F, 0x00);

    const h = [0x4D, 0x54, 0x68, 0x64, 0,0,0,6, 0,0, 0,1, 0x01, 0xF4];
    const trkHead = [0x4D, 0x54, 0x72, 0x6B]; 
    const len = trackData.length;
    const lenBytes = [(len>>24)&0xFF, (len>>16)&0xFF, (len>>8)&0xFF, len&0xFF];

    const finalBytes = new Uint8Array([...h, ...trkHead, ...lenBytes, ...trackData]);
    const blob = new Blob([finalBytes], {type: "audio/midi"});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `V9_Export_${gFilename}.mid`;
    link.click();
}

// ------------------------------------------
// Utils
// ------------------------------------------
function analyzeTracks(midi){
    return midi.tracks.map(t => {
        let sumP=0, sumD=0, cnt=0;
        t.notes.forEach(n=>{sumP+=n.midi; sumD+=n.duration; cnt++});
        return cnt===0 ? {avgP:0, avgD:0} : {avgP:sumP/cnt, avgD:sumD/cnt};
    });
}
function classifyTracks(stats){
    const valid = stats.filter(s=>s.avgP>0);
    const globalP = valid.length ? valid.reduce((s,a)=>s+a.avgP,0)/valid.length : 60;
    return stats.map(s => {
        if(s.avgP===0) return 'acc';
        if(s.avgP < 45) return 'bass';
        if(s.avgP > globalP && s.avgD > 0.25) return 'melody';
        return 'acc';
    });
}
function extractRawEvents(midi, roles) {
    let evs = [];
    midi.tracks.forEach((t, i) => {
        t.notes.forEach(n => {
            if(n.duration >= 0.01) {
                // Add trackIdx and initial status
                evs.push({ t: n.time, type: 1, p: n.midi, v: n.velocity, dur: n.duration, role: roles[i], trackIdx: i });
            }
        });
    });
    return evs.sort((a,b)=>a.t-b.t);
}
function formatTime(s) {
    const m = Math.floor(s/60);
    const sec = Math.floor(s%60);
    return `${m}:${sec.toString().padStart(2,'0')}`;
}

// Updated Allocator with Priority
function simulateAllocation(events, maxV) {
    let voices = Array(maxV).fill(null).map(()=>({act:false, id:-1, t:0, prio:0}));
    let map = new Map();
    let res = [];
    let drop = 0;
    
    for(let e of events) {
        if(e.type===1) {
            // Find empty
            let idx = voices.findIndex(v=>!v.act);
            
            // If full, try steal
            if(idx===-1) {
                // Candidates: lower priority, or same priority but older
                // Sort active voices by Prio (Asc) then Time (Asc = older)
                // We want to find the 'weakest' voice
                let candidates = voices.map((v,i)=>({v,i})).sort((a,b) => {
                    if(a.v.prio !== b.v.prio) return a.v.prio - b.v.prio;
                    return a.v.t - b.v.t; // Older first
                });
                
                let victim = candidates[0];
                
                // If incoming event is Higher or Equal priority, steal
                if(e.prio >= victim.v.prio) {
                    idx = victim.i;
                    if(voices[idx].id!==-1) map.delete(voices[idx].id);
                    drop++; // technically a drop of the old note
                } else {
                    drop++; // Incoming note dropped
                    continue;
                }
            }
            
            voices[idx] = {act:true, id:e.id, t:e.t, prio:e.prio};
            map.set(e.id, idx);
            res.push({t:e.t, type:1, ch:idx, p:e.p, v:e.v});
        } else {
            if(map.has(e.id)) {
                let idx = map.get(e.id);
                if(voices[idx].id===e.id) {
                    voices[idx].act=false;
                    res.push({t:e.t, type:0, ch:idx, p:0, v:0});
                }
                map.delete(e.id);
            }
        }
    }
    return {events:res, dropped:drop};
}

// ==========================================
// 7. Binary Stream Encoder & Code Generator (V9.3)
// ==========================================
function encodeBinaryStream(events) {
    let bytes = [];
    let lastT = 0;

    events.forEach(e => {
        let dt = e.t - lastT;
        lastT = e.t;

        // Delayのエンコード (127msを超える場合は複数回に分ける)
        while(dt > 0) {
            let wait = Math.min(127, dt);
            bytes.push(wait);
            dt -= wait;
        }

        // コマンドのエンコード
        // R3/1-bitはベロシティ無視なので [Cmd+Ch] [Note] の2バイトだけ
        if(e.type === 1) { // Note ON
            bytes.push(0x90 | (e.ch & 0x0F));
            bytes.push(e.p);
        } else { // Note OFF
            bytes.push(0x80 | (e.ch & 0x0F));
            bytes.push(e.p);
        }
    });
    bytes.push(0xF0); // End
    return bytes;
}

function generateSketch(mcu, events, vCount, tuningMode) {
    const d = new Date();
    const dateStr = d.getFullYear() + "-" + (d.getMonth()+1).toString().padStart(2,'0') + "-" + d.getDate().toString().padStart(2,'0');
    const headerInfo = `/* Generated: ${dateStr} | Source: ${gFilename} */`;
    
    // エンジン判定 (R4/Pico共通: 1BIT=DigitalArray, PWM=AudioMode)
    const engineMode = document.getElementById('engineSelect').value;
    
    // ==================================================================================
    // 1. Raspberry Pi Pico / Pico 2 (Unified Engine: PWM & 1-BIT)
    // ==================================================================================
    if (mcu === "Pico" || mcu === "Pico2") {
        const isPico2 = (mcu === "Pico2");
        const targetName = isPico2 ? "Raspberry Pi Pico 2 (RP2350)" : "Raspberry Pi Pico (RP2040)";
        
        // -----------------------------------------------------
        // A. 1-BIT MODE (R4 Style: Retro Sound & Memory Optimized)
        // -----------------------------------------------------
        if (engineMode === "1BIT") {
            // バイナリストリーム生成（R4と同じ圧縮方式）
            const binData = encodeBinaryStream(events);
            const hexData = binData.map(b => "0x" + b.toString(16).toUpperCase().padStart(2,'0')).join(",");
            const SAMPLE_RATE = 40000; // 40kHz loop

            // 周波数テーブル (16bit Step)
            let freqTable = [];
            for(let i=0; i<128; i++){
                const f = getFrequency(i, tuningMode);
                let step = Math.round((f * 65536.0) / SAMPLE_RATE);
                freqTable.push(step);
            }
            const pins = PIN_MAP[mcu].slice(0, vCount).join(",");

            return `${headerInfo}
/* Target: ${targetName}
 * Mode: V9.3 1-BIT DDS (Memory Optimized / Retro Style)
 * Engine: Dual Core (Core0: Sequencer, Core1: Audio Loop)
 */
#include <Arduino.h>
#include "pico/multicore.h"
#include "hardware/gpio.h"

const int pins[] = {${pins}};
const uint16_t STEPS[] = {${freqTable.join(",")}};
const uint8_t SCORE[] = {${hexData}}; // Binary Compressed Data

// Audio State
volatile uint16_t acc[${vCount}];
volatile uint16_t inc[${vCount}];
volatile bool     on[${vCount}];
uint32_t pin_masks[${vCount}];

// Core 1: Audio Engine (Dedicated High-Speed Loop)
void core1_entry() {
    // Cache GPIO toggle register for maximum speed
    volatile uint32_t *gpio_togl = &sio_hw->gpio_togl;
    
    while (1) {
        for(int i=0; i<${vCount}; i++) {
            if(on[i]) {
                acc[i] += inc[i];
                if(acc[i] < inc[i]) { // Overflow
                    *gpio_togl = pin_masks[i]; // Atomic Toggle
                }
            }
        }
        // Wait to maintain approx 40kHz sample rate
        // (Adjust loop overhead: 25us - overhead)
        sleep_us(18); 
    }
}

void setup() {
    for(int i=0; i<${vCount}; i++) {
        pinMode(pins[i], OUTPUT);
        digitalWrite(pins[i], LOW);
        pin_masks[i] = (1ul << pins[i]); // Create bitmask
        on[i] = false;
        acc[i] = 0;
        inc[i] = 0;
    }
    // Launch Audio Core
    multicore_launch_core1(core1_entry);
}

void loop() {
  static uint32_t csr = 0;
  static uint32_t nextT = 0;
  
  // Sequencer Logic (Same as R4 1-bit)
  if(millis() < nextT) return;

  while(true) {
    uint8_t b = SCORE[csr++];
    
    if(b == 0xF0) { // End of Song
       for(int i=0;i<${vCount};i++) on[i]=false; 
       delay(1000);
       csr = 0;
       nextT = millis();
       return; 
    }
    
    if(b < 128) { // Delay
       if(b > 0) {
         nextT = millis() + b;
         return; 
       }
    } else { // Command
       uint8_t ch = b & 0x0F;
       bool isNoteOn = (b & 0xF0) == 0x90;
       uint8_t note = SCORE[csr++];
       
       if(ch < ${vCount}) {
         if(isNoteOn) {
           inc[ch] = STEPS[note];
           on[ch] = true;
         } else {
           on[ch] = false;
         }
       }
    }
  }
}`;
        }
        
        // -----------------------------------------------------
        // B. PWM MODE (High Fidelity / Velocity Support)
        // -----------------------------------------------------
        // ★以前のコード(PWM版)はそのままここに入ります
        // ※以下の部分は修正前のコードと同じです
        const SAMPLE_RATE = 40000; 
        const dataStr = events.map(e => `{${e.t},${e.type},${e.ch},${e.p},${e.v}}`).join(",");
        let freqTable = [];
        for(let i=0; i<128; i++){
            const f = getFrequency(i, tuningMode);
            let step = Math.round((f * 65536.0) / SAMPLE_RATE);
            freqTable.push(step);
        }
        const pins = PIN_MAP[mcu].slice(0, vCount).join(",");

        return `${headerInfo}
/* Target: ${targetName}
 * Mode: V9.3 PRO Soft PWM (High Fidelity)
 * Fixes: Pitch correction, Soft sound, Clean Cutoff
 */
#include <Arduino.h>
#include "pico/multicore.h"

const int pins[] = {${pins}};
const uint32_t STEPS[] = {${freqTable.join(",")}};

// Event Structure
struct Event { uint32_t t; uint8_t type; uint8_t ch; uint8_t p; uint8_t v; };
const Event score[] = {${dataStr}};
const size_t SCORE_LEN = ${events.length};

// Voice State
struct Voice {
    bool active;
    uint16_t acc;
    uint16_t inc;
    uint16_t duty;
    uint32_t mask;
};
volatile Voice voices[${vCount}];

const int MAX_DUTY_PERCENT = 20; 

void core1_entry() {
    volatile uint32_t *set_reg = &sio_hw->gpio_set;
    volatile uint32_t *clr_reg = &sio_hw->gpio_clr;
    
    for(int i=0; i<${vCount}; i++) {
        voices[i].mask = (1ul << pins[i]);
        voices[i].active = false;
        *clr_reg = voices[i].mask;
    }

    while (1) {
        for(int i=0; i<${vCount}; i++) {
            if(voices[i].active) {
                voices[i].acc += voices[i].inc;
                if(voices[i].acc < voices[i].duty) {
                    *set_reg = voices[i].mask;
                } else {
                    *clr_reg = voices[i].mask;
                }
            } else {
                *clr_reg = voices[i].mask;
            }
        }
        sleep_us(22); 
    }
}

void setup() {
    for(int i=0; i<${vCount}; i++) {
        pinMode(pins[i], OUTPUT);
        digitalWrite(pins[i], LOW);
    }
    multicore_launch_core1(core1_entry);
}

void loop() {
  static uint32_t st = millis();
  static size_t idx = 0;
  
  if(idx >= SCORE_LEN) {
     delay(1000);
     for(int i=0; i<${vCount}; i++) voices[i].active = false;
     idx = 0;
     st = millis();
  }
  
  if(millis() < st) st = millis();
  uint32_t now = millis() - st;

  while(idx < SCORE_LEN) {
      if(score[idx].t > now) break; 
      
      uint8_t type = score[idx].type;
      uint8_t ch   = score[idx].ch;
      uint8_t p    = score[idx].p;
      uint8_t v    = score[idx].v;
      
      if(ch < ${vCount}) {
          if(type == 1) { // Note On
              voices[ch].inc = STEPS[p];
              uint32_t targetDuty = (65536 * MAX_DUTY_PERCENT) / 100;
              uint32_t vol = (uint32_t)v * targetDuty / 127;
              if(vol < 500) vol = 500;
              voices[ch].duty = (uint16_t)vol;
              voices[ch].acc = 0;
              voices[ch].active = true;
          } else { // Note Off
              voices[ch].active = false;
          }
      }
      idx++;
  }
}`;
    }

    // ---------------------------------------------------------
    // R3 (ATmega328P) & R4 1-bit Mode Logic
    // ---------------------------------------------------------
    if (mcu === "R3" || (mcu === "R4" && engineMode === "1BIT")) {
        const isR3 = (mcu === "R3");
        
        // 周波数テーブル生成 (16bit Step)
        // R3: 15kHz, R4: 24kHz (少し高音質化)
        const SAMPLE_RATE = isR3 ? 15000 : 24000;
        let freqTable = [];
        for(let i=0; i<128; i++){
            const f = getFrequency(i, tuningMode);
            let step = Math.round((f * 65536.0) / SAMPLE_RATE);
            if(step > 65535) step = 65535;
            freqTable.push(step);
        }

        // バイナリストリーム生成
        const binData = encodeBinaryStream(events);
        const hexData = binData.map(b => "0x" + b.toString(16).toUpperCase().padStart(2,'0')).join(",");

        // ピン定義 (R3は A0 を使うように修正)
        let pinDef = "";
        if(isR3) {
            // R3 Pin Mapping logic (Port manipulation requires fixed pins)
            pinDef = "// Pins: 2,3,4,5,6,7,8,9,10,11,12,A0";
        } else {
            const p = PIN_MAP["R4"].slice(0, vCount).join(",");
            pinDef = `const int pins[] = {${p}};`;
        }

        // -----------------------------------------------------
        // R3 Code Template (Memory Optimized)
        // -----------------------------------------------------
        if(isR3) {
            return `${headerInfo}
/* Target: Arduino UNO R3 (ATmega328P)
 * Engine: 12-Voice 1-bit DDS (Memory Optimized Binary Stream)
 * Pins: 2-12, A0 (Total 12)
 */
#include <Arduino.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>

const uint16_t STEPS[] PROGMEM = {${freqTable.join(",")}};
const uint8_t SCORE[] PROGMEM = {${hexData}};

volatile uint16_t acc[12];
volatile uint16_t inc[12];
volatile uint8_t  on[12];

// 15kHz Interrupt
ISR(TIMER1_COMPA_vect) {
  // Voice 0-5 (Port D 2-7)
  acc[0]+=inc[0]; if(on[0]&&(acc[0]<inc[0])) PIND=0x04; // Pin 2
  acc[1]+=inc[1]; if(on[1]&&(acc[1]<inc[1])) PIND=0x08;
  acc[2]+=inc[2]; if(on[2]&&(acc[2]<inc[2])) PIND=0x10;
  acc[3]+=inc[3]; if(on[3]&&(acc[3]<inc[3])) PIND=0x20;
  acc[4]+=inc[4]; if(on[4]&&(acc[4]<inc[4])) PIND=0x40;
  acc[5]+=inc[5]; if(on[5]&&(acc[5]<inc[5])) PIND=0x80; // Pin 7
  
  // Voice 6-10 (Port B 0-4 -> Pins 8-12)
  acc[6]+=inc[6]; if(on[6]&&(acc[6]<inc[6])) PINB=0x01; // Pin 8
  acc[7]+=inc[7]; if(on[7]&&(acc[7]<inc[7])) PINB=0x02;
  acc[8]+=inc[8]; if(on[8]&&(acc[8]<inc[8])) PINB=0x04;
  acc[9]+=inc[9]; if(on[9]&&(acc[9]<inc[9])) PINB=0x08;
  acc[10]+=inc[10]; if(on[10]&&(acc[10]<inc[10])) PINB=0x10; // Pin 12

  // Voice 11 (Port C 0 -> Pin A0)
  acc[11]+=inc[11]; if(on[11]&&(acc[11]<inc[11])) PINC=0x01; // Pin A0 (14)
}

void setup() {
  DDRD |= 0xFC; // 2-7
  DDRB |= 0x1F; // 8-12
  DDRC |= 0x01; // A0
  
  // Timer1 15kHz
  cli();
  TCCR1A = 0; TCCR1B = 0; TCNT1 = 0;
  OCR1A = 1066; // 16MHz/15000
  TCCR1B |= (1 << WGM12) | (1 << CS10);
  TIMSK1 |= (1 << OCIE1A);
  sei();
}

void loop() {
  static uint32_t csr = 0;
  static uint32_t nextT = 0;
  
  if(millis() < nextT) return;

  while(true) {
    uint8_t b = pgm_read_byte(&SCORE[csr++]);
    
    if(b == 0xF0) { // End
       for(int i=0;i<12;i++) on[i]=0; // 全音オフ
       delay(1000);      // 1秒待機
       csr = 0;          // 読み込み位置を最初に戻す
       nextT = millis(); // タイマー基準をリセット
       return;           // loop()の先頭に戻る
    }
    
    if(b < 128) { // Delay
       if(b > 0) {
         nextT = millis() + b;
         return; // Wait until nextT
       }
    } else { // Command
       uint8_t ch = b & 0x0F;
       bool isNoteOn = (b & 0xF0) == 0x90;
       uint8_t note = pgm_read_byte(&SCORE[csr++]);
       
       if(ch < 12) {
         if(isNoteOn) {
           inc[ch] = pgm_read_word(&STEPS[note]);
           on[ch] = 1;
         } else {
           on[ch] = 0;
         }
       }
    }
  }
}`;
        } else {
            // -----------------------------------------------------
            // R4 1-bit Mode Code (High Performance / Register Direct)
            // -----------------------------------------------------
            return `${headerInfo}
/* Target: Arduino UNO R4
 * Engine: ${vCount}-Voice 1-bit DDS (High Performance Register Access)
 */
#include <Arduino.h>
#include "FspTimer.h"

${pinDef}
const uint32_t STEPS[] = {${freqTable.join(",")}};
const uint8_t SCORE[] = {${hexData}};

FspTimer timer;
volatile uint16_t acc[${vCount}];
volatile uint16_t inc[${vCount}];
volatile uint8_t  on[${vCount}];

// 高速化のための構造体
struct PinPtr {
    volatile uint16_t* portReg; // ポート出力レジスタへのポインタ
    uint16_t mask;              // ピンに対応するビットマスク
};
PinPtr pp[${vCount}];

void isr(timer_callback_args_t *args) {
    for(int i=0; i<${vCount}; i++) {
        if(on[i]) {
            acc[i] += inc[i];
            if(acc[i] < inc[i]) {
                // digitalWriteの代わりにレジスタを直接XOR反転（爆速）
                *pp[i].portReg ^= pp[i].mask;
            }
        }
    }
}

void setup() {
    for(int i=0; i<${vCount}; i++) {
        pinMode(pins[i], OUTPUT);
        // R4のレジスタアドレスを計算してキャッシュする
        bsp_io_port_pin_t p = (bsp_io_port_pin_t)g_pin_cfg[pins[i]].pin;
        // PODR (Port Output Data Register) のアドレスを取得
        pp[i].portReg = (volatile uint16_t*)&((R_PORT0_Type*)((uint32_t)R_PORT0 + ((p >> 8) * 0x20)))->PODR;
        pp[i].mask = 1 << (p & 0xFF);
    }
    
    uint8_t type;
    int8_t ch = FspTimer::get_available_timer(type);
    timer.begin(TIMER_MODE_PERIODIC, type, ch, ${SAMPLE_RATE}, 0.0f, isr);
    timer.setup_overflow_irq();
    timer.open();
    timer.start();
}

void loop() {
  static uint32_t csr = 0;
  static uint32_t nextT = 0;
  
  if(millis() < nextT) return;

  while(true) {
    uint8_t b = SCORE[csr++];
    
    if(b == 0xF0) { 
        // 終了時の処理（ループ再生対応済み）
        for(int i=0;i<${vCount};i++) on[i]=0; 
        delay(1000);
        csr = 0;
        nextT = millis();
        return; 
    }
    
    if(b < 128) {
       if(b > 0) { nextT = millis() + b; return; }
    } else {
       uint8_t ch = b & 0x0F;
       bool isNoteOn = (b & 0xF0) == 0x90;
       uint8_t note = SCORE[csr++];
       
       if(ch < ${vCount}) {
         if(isNoteOn) {
           inc[ch] = STEPS[note];
           on[ch] = 1;
         } else {
           on[ch] = 0;
         }
       }
    }
  }
}`;
        }
    }

    // ---------------------------------------------------------
    // R4 (PWM) & ESP32 (Legacy Standard)
    // ---------------------------------------------------------
    const pins = PIN_MAP[mcu] ? PIN_MAP[mcu].slice(0, vCount).join(", ") : "";
    const dataStr = events.map(e => `{${e.t},${e.type},${e.ch},${e.p},${Math.min(255, e.v)}}`).join(",");
    let r4T=[]; let espT=[]; 
    for(let i=0;i<128;i++) {
        const freq = getFrequency(i, tuningMode);
        r4T.push(Math.round(freq * 4294967296.0 / 20000) + "UL");
        espT.push(Math.round(freq));
    }

    if(mcu === "R4") { // R4 PWM Mode
        return `${headerInfo} /* R4 PWM Mode */
#include <Arduino.h>
#include "FspTimer.h"
constexpr uint32_t SR=20000;
constexpr uint8_t NV=${vCount};
const int pins[]={${pins}};
const uint32_t STEP[]={${r4T.join(",")}};
struct E{uint32_t t;uint8_t tp;uint8_t c;uint8_t p;uint8_t v;};
const E sc[]={${dataStr}};
const size_t LEN=${events.length};
FspTimer tm;
struct FP{volatile uint16_t* r;uint16_t m;}; FP fp[NV];
struct V{bool a;uint32_t ph;uint32_t bs;uint32_t cs;int32_t cd;int32_t td;bool b;uint32_t l;};
volatile V v[NV];
void isr(timer_callback_args_t* a){
 static uint32_t tk=0; tk++;
 for(int i=0;i<NV;i++){
  if(v[i].a){
   v[i].l+=(v[i].b)?80:120;
   int32_t dm=0;
   if(v[i].b){int32_t l=(v[i].l>>8)&31;dm=((v[i].l&0x2000)?l:(31-l))*2;}
   else{int32_t m=(v[i].l&0x8000)?250000:-250000;v[i].cs=v[i].bs+m;}
   v[i].ph+=(v[i].b?v[i].bs:v[i].cs);
   if((tk&31)==0){if(v[i].cd>0)v[i].cd--;else{v[i].a=0;*fp[i].r&=~fp[i].m;continue;}}
   if((v[i].ph>>23)<(uint32_t)(v[i].cd+dm<1?1:v[i].cd+dm)) *fp[i].r|=fp[i].m; else *fp[i].r&=~fp[i].m;
  }
 }
}
void setup(){
 for(int i=0;i<NV;i++){
  pinMode(pins[i],OUTPUT);
  bsp_io_port_pin_t p=(bsp_io_port_pin_t)g_pin_cfg[pins[i]].pin;
  fp[i].r=(volatile uint16_t*)&((R_PORT0_Type*)((uint32_t)R_PORT0+((p>>8)*0x20)))->PODR;
  fp[i].m=1<<(p&0xFF);
 }
 uint8_t t;int8_t c=FspTimer::get_available_timer(t);
 tm.begin(TIMER_MODE_PERIODIC,t,c,SR,0.0f,isr);
 tm.setup_overflow_irq();tm.open();tm.start();
}
void loop(){
 static uint32_t st=millis();static size_t i=0;
 if(i>=LEN){delay(1000);for(int j=0;j<NV;j++)v[j].a=0;i=0;st=millis();}
 if(millis()<st)st=millis();
 uint32_t now=millis()-st;
 while(i<LEN){
  if(sc[i].t>now)break;
  if(sc[i].tp==1){
   uint8_t c=sc[i].c;
   if(c<NV){
    v[c].bs=STEP[sc[i].p];v[c].cs=v[c].bs;v[c].l=0;v[c].b=(sc[i].p<55);
    int td=(sc[i].p<55)?120:(sc[i].p>85?40:64);
    int d=map(sc[i].v,0,127,2,td);
    if(sc[i].v > 130) d = td;
    v[c].td=td;v[c].cd=d;v[c].a=1;
   }
  }else{if(sc[i].c<NV)v[sc[i].c].a=0;}
  i++;
 }
}`;
    }

    // ESP32 Code
    return `/* MIDI PRO V9.3 (${tuningMode}) for ESP32 ${headerInfo}
#include <Arduino.h>
constexpr uint8_t NV=${vCount};
const int pins[]={${pins}};
const uint16_t F[]={${espT.join(",")}};
struct E{uint32_t t;uint8_t tp;uint8_t c;uint8_t p;uint8_t v;};
const E sc[]={${dataStr}};
const size_t LEN=${events.length};
#if defined(ESP_ARDUINO_VERSION_MAJOR)&&ESP_ARDUINO_VERSION_MAJOR>=3
#define V3
#else
const int ch[]={0,1,2,3,4,5,6,7,8,9,10,11};
#endif
void setup(){
 for(int i=0;i<NV;i++){
 #ifdef V3
  ledcAttach(pins[i],2000,8);
 #else
  ledcSetup(ch[i],2000,8);ledcAttachPin(pins[i],ch[i]);
 #endif
 }
}
void loop(){
 static uint32_t st=millis();static size_t i=0;
 if(i>=LEN){delay(1000);for(int j=0;j<NV;j++){
  #ifdef V3
  ledcWrite(pins[j],0);
  #else
  ledcWrite(ch[j],0);ledcWriteTone(ch[j],0);
  #endif
 }i=0;st=millis();}
 if(millis()<st)st=millis();
 uint32_t now=millis()-st;
 while(i<LEN){
  if(sc[i].t>now)break;
  if(sc[i].tp==1){
   uint8_t c=sc[i].c; uint8_t p=sc[i].p;
   if(c<NV){
    int maxD = 128; 
    int d = 0;
    if(sc[i].v > 127) {
        d = 128;
    } else {
        int md=(p<55)?128:(p>85?40:64);
        d=map(sc[i].v,1,127,1,md);
    }
    #ifdef V3
    ledcWriteTone(pins[c],F[p]);ledcWrite(pins[c],d);
    #else
    ledcWriteTone(ch[c],F[p]);ledcWrite(ch[c],d);
    #endif
   }
  }else{
   uint8_t c=sc[i].c;
   if(c<NV){
    #ifdef V3
    ledcWrite(pins[c],0);
    #else
    ledcWrite(ch[c],0);ledcWriteTone(ch[c],0);
    #endif
   }
  }
  i++;
 }
}`;
}
updateLanguageUI();
</script>
</body>
</html>
